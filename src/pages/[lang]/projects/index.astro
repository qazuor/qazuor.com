---
import { getCollection } from 'astro:content';
import { ProjectCard } from '@/components/cards/ProjectCard';
import { ActiveFilters } from '@/components/ui/ActiveFilters';
import AnimatedGradientBackground from '@/components/ui/AnimatedGradientBackground.astro';
import SecondaryTitle from '@/components/ui/SecondaryTitle.astro';
import SectionTitle from '@/components/ui/SectionTitle.astro';
import { TechnologyFilter } from '@/components/ui/TechnologyFilter';
import { sectionsColors } from '@/data';
import { languages } from '@/i18n/ui';
import { getLangFromUrl, getTranslations } from '@/i18n/utils';
import BaseLayout from '@/layouts/BaseLayout.astro';

export function getStaticPaths() {
    return Object.keys(languages).map((lang) => ({
        params: { lang }
    }));
}

const lang = getLangFromUrl(Astro.url);
const t = getTranslations(lang);

// Load Content Collections
const allProjects = await getCollection('projects');

// Sort projects: featured first, then by order field, then by date
const sortedProjects = allProjects
    .sort((a, b) => {
        // Featured projects come first
        const aFeatured = a.data.featured || false;
        const bFeatured = b.data.featured || false;
        if (aFeatured !== bFeatured) {
            return bFeatured ? 1 : -1;
        }
        // Then by order
        if (a.data.order !== b.data.order) {
            return a.data.order - b.data.order;
        }
        // Finally by date
        return b.data.publishDate.getTime() - a.data.publishDate.getTime();
    })
    .map((project) => ({
        title: project.data.title,
        description: project.data.description,
        slug: project.data.slug || project.slug,
        category: project.data.category as 'open-source' | 'commercial' | 'client',
        technologies: project.data.technologies,
        images: project.data.images.map((img) => img.src),
        featured: project.data.featured || false,
        order: project.data.order
    }));

// Group projects by category
const projectsByCategory = {
    'open-source': sortedProjects.filter((p) => p.category === 'open-source'),
    commercial: sortedProjects.filter((p) => p.category === 'commercial'),
    client: sortedProjects.filter((p) => p.category === 'client')
};

// Extract all unique technologies
const allTechnologies = Array.from(new Set(sortedProjects.flatMap((p) => p.technologies))).sort();

// Translations
const pageTitle = `${t('projects.title')} - qazuor.com`;
const translations = {
    title: t('projects.title', { markdown: true }),
    subtitle: t('projects.subtitle', { markdown: true }),
    noResults: t('projects.noResults')
};

const filterTranslations = {
    filterButton: t('projects.filters.filterButton'),
    searchPlaceholder: t('projects.filters.searchPlaceholder'),
    selectAll: t('projects.filters.selectAll'),
    clearAll: t('projects.filters.clearAll'),
    activeFilters: t('projects.filters.activeFilters'),
    activeFiltersLabel: t('projects.filters.activeFiltersLabel'),
    moreFilters: t('projects.filters.moreFilters'),
    clearFilters: t('projects.filters.clearFilters'),
    noResults: t('projects.filters.noResults')
};

const categoryTitles = {
    'open-source': t('projects.categoryTitles.openSource'),
    commercial: t('projects.categoryTitles.commercial'),
    client: t('projects.categoryTitles.client')
};

const cardTranslations = {
    viewProject: t('projects.card.viewProject'),
    categories: {
        openSource: t('projects.card.categories.openSource'),
        commercial: t('projects.card.categories.commercial'),
        client: t('projects.card.categories.client')
    },
    moreTechnologies: t('projects.card.moreTechnologies')
};
---

<BaseLayout title={pageTitle}>
	<section class="relative min-h-screen overflow-hidden" style={`background-color: ${sectionsColors.projects}`}>
		<!-- Animated Gradient Background -->
		<AnimatedGradientBackground />

		<div class="container-custom py-16 relative z-10">
			<!-- Section Title -->
			<SectionTitle title={translations.title} subtitle={translations.subtitle} />

			<!-- Filter Section -->
			<div class="mb-8 flex flex-col md:flex-row md:justify-between md:items-start gap-4">
				<!-- Filter Button (top on mobile, right on desktop) -->
				<div class="w-full md:w-auto md:order-2" id="filter-button-container"></div>

				<!-- Active Filters (bottom on mobile, left on desktop) -->
				<div class="w-full md:flex-1 md:min-w-0 md:order-1" id="active-filters-container"></div>
			</div>

			<!-- Store translations for JavaScript -->
			<script id="filter-translations" type="application/json" set:html={JSON.stringify(filterTranslations)}></script>

			<!-- Store category titles for JavaScript -->
			<script id="category-titles" type="application/json" set:html={JSON.stringify(categoryTitles)}></script>

			<!-- Categories Container -->
			<div id="categories-container">
			{
				Object.entries(projectsByCategory).map(([category, projects]) => {
					if (projects.length === 0) return null;

					return (
						<div class="mb-16 category-section" data-category={category}>
							<div class="mb-8 flex items-center gap-3">
								<span class="w-2 h-8 bg-primary rounded-full" />
								<SecondaryTitle
									text={categoryTitles[category as keyof typeof categoryTitles]}
									element="h2"
									size="xl"
									showHtml={false}
								/>
								<span class="category-count text-lg font-normal text-foreground-secondary">
									({projects.length})
								</span>
							</div>

							<div class="projects-grid flex flex-wrap -mx-3">
								{projects.map((project) => (
									<div
										class="project-card w-full md:w-1/2 lg:w-1/3 px-3 mb-6"
										data-technologies={JSON.stringify(project.technologies)}
									>
										<ProjectCard
											client:load
											title={project.title}
											description={project.description}
											technologies={project.technologies}
											images={project.images}
											slug={project.slug}
											variant="list"
											lang={lang}
											category={project.category}
											featured={project.featured}
											translations={cardTranslations}
										/>
									</div>
								))}
							</div>
						</div>
					);
				})
			}
			</div>

			<!-- Empty State -->
			<div id="empty-state" class="hidden text-center py-16">
				<svg
					class="w-24 h-24 mx-auto mb-4 text-foreground-secondary opacity-50"
					fill="none"
					stroke="currentColor"
					viewBox="0 0 24 24"
				>
					<path
						stroke-linecap="round"
						stroke-linejoin="round"
						stroke-width="1.5"
						d="M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
					></path>
				</svg>
				<p class="text-foreground-secondary text-lg">{translations.noResults}</p>
			</div>
		</div>
	</section>
</BaseLayout>

<script>
	import { ActiveFilters } from '@/components/ui/ActiveFilters';
import { TechnologyFilter } from '@/components/ui/TechnologyFilter';
import autoAnimate from '@formkit/auto-animate';
import { createElement } from 'react';
import { createRoot } from 'react-dom/client';

	// Get all technologies and translations from the page
	const allProjects = document.querySelectorAll('.project-card');
	const allTechnologies = Array.from(
		new Set(
			Array.from(allProjects).flatMap((card) => {
				const techs = card.getAttribute('data-technologies');
				return techs ? JSON.parse(techs) : [];
			})
		)
	).sort();

	// Get translations from the JSON script tag
	const translationsScript = document.getElementById('filter-translations');
	const filterTranslations = translationsScript ? JSON.parse(translationsScript.textContent || '{}') : {};

	let selectedTechnologies: string[] = [];
	let filterRoot: ReturnType<typeof createRoot> | null = null;
	let activeRoot: ReturnType<typeof createRoot> | null = null;

	// Store all cards on initial load for each category
	const allCardsByCategory = new Map<HTMLElement, HTMLElement[]>();
	// Store all category sections
	const allCategorySections = new Map<string, HTMLElement>();

	// Function to apply filters
	function applyFilters(technologies: string[]) {
		selectedTechnologies = technologies;
		const categoriesContainer = document.getElementById('categories-container');
		if (!categoriesContainer) return;

		let totalVisible = 0;

		// Store all category sections on first run
		if (allCategorySections.size === 0) {
			const sections = document.querySelectorAll('.category-section');
			sections.forEach((section) => {
				const category = (section as HTMLElement).getAttribute('data-category');
				if (category) {
					allCategorySections.set(category, section as HTMLElement);
				}
			});
		}

		// Determine which categories should be visible
		const visibleCategories = new Map<string, number>();

		allCategorySections.forEach((section, category) => {
			const projectsGrid = section.querySelector('.projects-grid') as HTMLElement;
			if (!projectsGrid) return;

			// Store all cards on first run
			if (!allCardsByCategory.has(section)) {
				const cards = Array.from(section.querySelectorAll('.project-card')) as HTMLElement[];
				allCardsByCategory.set(section, cards);
			}

			const allCards = allCardsByCategory.get(section) || [];

			// Determine which cards should be visible
			const visibleCards = allCards.filter((card) => {
				const cardTechs = JSON.parse(card.getAttribute('data-technologies') || '[]') as string[];
				return technologies.length === 0 || technologies.every((tech) => cardTechs.includes(tech));
			});

			// Get currently visible cards in the grid
			const currentCards = Array.from(projectsGrid.children) as HTMLElement[];

			// Remove cards that shouldn't be visible
			currentCards.forEach((card) => {
				if (!visibleCards.includes(card)) {
					projectsGrid.removeChild(card);
				}
			});

			// Add cards that should be visible but aren't
			visibleCards.forEach((card) => {
				if (!projectsGrid.contains(card)) {
					projectsGrid.appendChild(card);
				}
			});

			const visibleInCategory = visibleCards.length;
			totalVisible += visibleInCategory;

			// Update category count
			const countElement = section.querySelector('.category-count');
			if (countElement) {
				countElement.textContent = `(${visibleInCategory})`;
			}

			// Store visible count for this category
			if (visibleInCategory > 0) {
				visibleCategories.set(category, visibleInCategory);
			}
		});

		// Get currently visible category sections in the container
		const currentSections = Array.from(categoriesContainer.children) as HTMLElement[];

		// Remove category sections that shouldn't be visible
		currentSections.forEach((section) => {
			const category = section.getAttribute('data-category');
			if (category && !visibleCategories.has(category)) {
				categoriesContainer.removeChild(section);
			}
		});

		// Add category sections that should be visible but aren't
		allCategorySections.forEach((section, category) => {
			if (visibleCategories.has(category) && !categoriesContainer.contains(section)) {
				categoriesContainer.appendChild(section);
			}
		});

		// Show/hide empty state
		const emptyState = document.getElementById('empty-state');
		if (emptyState) {
			if (totalVisible === 0) {
				emptyState.classList.remove('hidden');
			} else {
				emptyState.classList.add('hidden');
			}
		}

		// Update URL
		const params = new URLSearchParams();
		if (technologies.length > 0) {
			params.set('tech', technologies.join(','));
		}
		const newUrl = params.toString() ? `?${params.toString()}` : window.location.pathname;
		window.history.replaceState({}, '', newUrl);
	}

	// Function to remove a technology
	function removeTechnology(tech: string) {
		const newTechnologies = selectedTechnologies.filter((t) => t !== tech);
		applyFilters(newTechnologies);
		renderComponents();
	}

	// Function to clear all filters
	function clearAllFilters() {
		applyFilters([]);
		renderComponents();
	}

	// Render React components
	function renderComponents() {
		// Render Technology Filter Button
		const filterButtonContainer = document.getElementById('filter-button-container');
		if (filterButtonContainer) {
			if (!filterRoot) {
				filterRoot = createRoot(filterButtonContainer);
			}
			filterRoot.render(
				createElement(TechnologyFilter, {
					technologies: allTechnologies,
					selectedTechnologies: selectedTechnologies,
					onFilterChange: (techs: string[]) => {
						applyFilters(techs);
						// Use setTimeout to allow AutoAnimate to process the DOM changes first
						setTimeout(() => {
							renderComponents();
						}, 0);
					},
					translations: filterTranslations
				})
			);
		}

		// Render Active Filters
		const activeFiltersContainer = document.getElementById('active-filters-container');
		if (activeFiltersContainer) {
			if (!activeRoot) {
				activeRoot = createRoot(activeFiltersContainer);
			}
			activeRoot.render(
				createElement(ActiveFilters, {
					selectedTechnologies: selectedTechnologies,
					onRemove: removeTechnology,
					onClearAll: clearAllFilters,
					translations: {
						activeFilters: filterTranslations.activeFilters,
						activeFiltersLabel: filterTranslations.activeFiltersLabel,
						moreFilters: filterTranslations.moreFilters,
						clearAll: filterTranslations.clearFilters
					}
				})
			);
		}
	}

	// Initialize on page load
	document.addEventListener('DOMContentLoaded', () => {
		// Initialize AutoAnimate on categories container
		const categoriesContainer = document.getElementById('categories-container');
		if (categoriesContainer) {
			autoAnimate(categoriesContainer, {
				duration: 400,
				disrespectUserMotionPreference: true
			});
		}

		// Initialize AutoAnimate on all project grids
		const projectGrids = document.querySelectorAll('.projects-grid');
		projectGrids.forEach((grid) => {
			autoAnimate(grid as HTMLElement, {
				duration: 400,
				disrespectUserMotionPreference: true
			});
		});

		// Read initial filters from URL
		const params = new URLSearchParams(window.location.search);
		const tech = params.get('tech');
		if (tech) {
			selectedTechnologies = tech.split(',').filter((t) => allTechnologies.includes(t));
		}

		// Apply initial filters and render components
		applyFilters(selectedTechnologies);
		renderComponents();
	});
</script>
