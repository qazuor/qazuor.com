---
// Import critical fonts and styles
// Note: fonts.css now handles font loading with proper critical/non-critical split
import '../styles/fonts.css';

// Import auto-generated colors
import '../styles/generated-colors.css';

// Astro image optimization
import { getImage } from 'astro:assets';
import { ViewTransitions } from 'astro:transitions';
// Vercel Analytics and Speed Insights
import Analytics from '@vercel/analytics/astro';
import SpeedInsights from '@vercel/speed-insights/astro';
import photo1 from '@/assets/images/photo1.png';
// Other imports
import AutoAnimateGlobal from '@/components/AutoAnimateGlobal.astro';
import { SmoothScroll } from '@/components/animations/SmoothScroll';
import BuildSearchIndex from '@/components/BuildSearchIndex.astro';
import { CommandPalette } from '@/components/interactive/CommandPalette';
import { ScrollToTop } from '@/components/interactive/ScrollToTop';
import LifecycleInit from '@/components/LifecycleInit.astro';
import Footer from '@/components/layout/Footer.astro';
import Navigation from '@/components/layout/Navigation.astro';
import SEO from '@/components/layout/SEO.astro';
import BreadcrumbJsonLd from '@/components/seo/BreadcrumbJsonLd.astro';
import JsonLd from '@/components/seo/JsonLd.astro';
import ViewTransitionGSAP from '@/components/transitions/ViewTransitionGSAP.astro';
// import PageTransition from '@/components/transitions/PageTransition.astro';
import { languages } from '@/i18n/ui';
import { getLangFromUrl, getRouteFromUrl, getTranslations } from '@/i18n/utils';
import type { PersonSchema, WebSiteSchema } from '@/types/jsonld';
import { generateBreadcrumbs } from '@/utils/breadcrumbs';

// Note: PixelCanvas custom element is registered via inline script below
// to ensure it works with View Transitions navigation

interface Props {
    title: string;
    description?: string;
    image?: string;
    imageAlt?: string;
    type?: 'website' | 'article' | 'profile';
    keywords?: string[];
    publishDate?: string;
    modifiedDate?: string;
    articleTags?: string[];
    noindex?: boolean;
    author?: string;
    jobTitle?: string;
    socialLinks?: {
        github?: string;
        linkedin?: string;
        fiverr?: string;
        upwork?: string;
    };
    /** Custom page name for breadcrumbs (optional) */
    breadcrumbName?: string;
    /** Disable breadcrumbs on this page */
    noBreadcrumbs?: boolean;
}

const lang = getLangFromUrl(Astro.url);
const t = getTranslations(lang);

// Optimize hero image for LCP (Largest Contentful Paint)
const optimizedPhoto = await getImage({
    src: photo1,
    format: 'webp'
});

const {
    title,
    description = t('home.description'),
    image,
    imageAlt,
    type = 'website',
    keywords = [],
    publishDate,
    modifiedDate,
    articleTags = [],
    noindex = false,
    author,
    jobTitle,
    socialLinks,
    breadcrumbName,
    noBreadcrumbs = false
} = Astro.props;

// Get current route without locale
const route = getRouteFromUrl(Astro.url);

// Site configuration
const siteUrl = 'https://qazuor.com';
const siteName = 'Qazuor';
const authorName = 'JuliÃ¡n Cataldo';

// Generate WebSite schema (for all pages)
const websiteSchema: WebSiteSchema = {
    '@context': 'https://schema.org',
    '@type': 'WebSite',
    name: siteName,
    url: siteUrl,
    description: t('home.description'),
    author: {
        '@type': 'Person',
        name: authorName
    },
    inLanguage: ['en', 'es'],
    potentialAction: {
        '@type': 'SearchAction',
        target: {
            '@type': 'EntryPoint',
            urlTemplate: `${siteUrl}/{lang}?search={search_term_string}`
        },
        'query-input': 'required name=search_term_string'
    }
};

// Generate breadcrumb items for this page
const breadcrumbItems = noBreadcrumbs ? [] : generateBreadcrumbs(Astro.url.pathname, siteUrl, breadcrumbName || title);

// Generate alternate language links
const locales = Object.keys(languages);
const alternateLinks = locales.map((locale) => {
    const path = `/${locale}${route}`;
    return { locale, path };
});
---

<!doctype html>
<html lang={lang} class="dark">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <!-- Performance: Preload Critical Resources -->
        <!-- Only preload fonts used above-the-fold (hero section) -->
        <!-- Using crossorigin="anonymous" is required for font preloading -->

        <!-- Inter 400 - Body text (used throughout hero section) -->
        <link
            rel="preload"
            href="/fonts/inter-latin-400-normal.woff2"
            as="font"
            type="font/woff2"
            crossorigin="anonymous"
        />

        <!-- Inter 600 - Subheadings (h2, h3) -->
        <link
            rel="preload"
            href="/fonts/inter-latin-600-normal.woff2"
            as="font"
            type="font/woff2"
            crossorigin="anonymous"
        />

        <!-- Inter 700 - Bold emphasis (CTAs and strong text) -->
        <link
            rel="preload"
            href="/fonts/inter-latin-700-normal.woff2"
            as="font"
            type="font/woff2"
            crossorigin="anonymous"
        />

        <!-- Inter 900 - Hero h1 (font-black) - Critical for LCP -->
        <link
            rel="preload"
            href="/fonts/inter-latin-900-normal.woff2"
            as="font"
            type="font/woff2"
            crossorigin="anonymous"
        />

        <!-- Preload LCP image (hero image) with high priority -->
        <!-- Optimized with Astro's getImage() for WebP format -->
        <link
            rel="preload"
            href={optimizedPhoto.src}
            as="image"
            fetchpriority="high"
        />

        <!-- Critical CSS (inlined for fastest LCP) -->
        <!-- Contains ONLY styles needed for above-the-fold hero section -->
        <!-- IMPORTANT: Must include BOTH light and dark themes to prevent flash during View Transitions -->
        <style is:inline>
            /* CSS Variables - Light Mode (base) */
            :root {
                --bg-primary: 219 21% 96%;
                --bg-secondary: 219 21% 94%;
                --text-primary: 215 25% 15%;
                --text-secondary: 215 20% 25%;
                --background: 219 21% 94%;
                --foreground: 215 25% 15%;
                --primary: 215 60% 40%;
                color-scheme: light;
            }

            /* CSS Variables - Dark Mode (override when .dark class present) */
            html.dark {
                --bg-primary: 256 45% 6%;
                --bg-secondary: 250 30% 10%;
                --text-primary: 240 15% 96%;
                --text-secondary: 240 10% 72%;
                --background: 256 45% 8%;
                --foreground: 240 15% 95%;
                --primary: 250 60% 65%;
                color-scheme: dark;
            }

            body {
                font-family: "Inter", system-ui, -apple-system, sans-serif;
                background: hsl(var(--background));
                color: hsl(var(--foreground));
                line-height: 1.5;
            }

            .container-custom {
                max-width: 80rem;
                margin-left: auto;
                margin-right: auto;
                padding-left: 1rem;
                padding-right: 1rem;
            }

            @media (min-width: 640px) {
                .container-custom {
                    padding-left: 1.5rem;
                    padding-right: 1.5rem;
                }
            }

            @media (min-width: 1024px) {
                .container-custom {
                    padding-left: 2rem;
                    padding-right: 2rem;
                }
            }

            .hero-section {
                position: relative;
                display: flex;
                justify-content: center;
                overflow: hidden;
                padding-top: 1rem;
            }

            @media (min-width: 1024px) {
                .hero-section {
                    align-items: center;
                    padding-top: 0;
                }
            }

            .gradient-text-hero {
                background: linear-gradient(to right, #2563eb, #7c3aed, #0ea5e9);
                background-size: 300% 100%;
                background-clip: text;
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                animation: gradient-shift 12s ease infinite;
            }

            html.dark .gradient-text-hero {
                background: linear-gradient(to right, #3b82f6, #8b5cf6, #06b6d4);
                background-size: 300% 100%;
                background-clip: text;
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
            }

            @keyframes gradient-shift {
                0% {
                    background-position: 0% 50%;
                }
                50% {
                    background-position: 100% 50%;
                }
                100% {
                    background-position: 0% 50%;
                }
            }

            .text-foreground {
                color: hsl(var(--foreground));
            }

            .text-foreground-secondary {
                color: hsl(var(--text-secondary));
            }

            .text-primary {
                color: hsl(var(--primary));
            }

            .font-black {
                font-weight: 900;
            }

            .font-semibold {
                font-weight: 600;
            }

            .font-bold {
                font-weight: 700;
            }

            .hero-element {
                opacity: 1;
            }

            .skip-link {
                position: absolute;
                top: -40px;
                left: 0;
                background: hsl(var(--background));
                color: hsl(var(--foreground));
                padding: 8px;
                text-decoration: none;
                z-index: 100;
            }

            .skip-link:focus {
                top: 0;
            }
        </style>

        <!-- SEO Component -->
        <SEO
            title={title}
            description={description}
            image={image}
            imageAlt={imageAlt}
            type={type}
            keywords={keywords}
            locale={lang}
            publishDate={publishDate}
            modifiedDate={modifiedDate}
            articleTags={articleTags}
            noindex={noindex}
            author={author}
            jobTitle={jobTitle}
            socialLinks={socialLinks}
        />

        <!-- Favicons are automatically injected by astro-favicons integration -->

        <!-- View Transitions (Astro official) -->
        <ViewTransitions />

        <!-- Alternate language links -->
        {
            alternateLinks.map(({ locale, path }) => (
                <link rel="alternate" hreflang={locale} href={`${Astro.site || ''}${path}`} />
            ))
        }

        <!-- JSON-LD Structured Data -->
        <JsonLd schema={websiteSchema} />
        {breadcrumbItems.length > 1 && <BreadcrumbJsonLd items={breadcrumbItems} />}

        <!-- Additional head content from pages -->
        <slot name="head" />

        <!-- Fix for View Transitions + GSAP ScrollTrigger conflict -->
        <!-- https://github.com/withastro/astro/issues/12725 -->
        <script is:inline>
            delete window.onscrollend;
        </script>


        <!-- Prevent flash of unstyled content (FOUC) for dark mode -->
        <!-- Also handles View Transitions theme persistence -->
        <script is:inline>
            (function() {
                function applyTheme() {
                    const theme = localStorage.getItem('theme');
                    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                    if (theme === 'dark' || (!theme && prefersDark)) {
                        document.documentElement.classList.add('dark');
                    } else {
                        document.documentElement.classList.remove('dark');
                    }
                }

                // Apply on initial load
                applyTheme();

                // Apply after View Transitions (uses custom event from ViewTransitionGSAP)
                document.addEventListener('qazuor:content-ready', applyTheme);

                // Also apply before swap to prevent flash during transition
                document.addEventListener('astro:before-swap', function(e) {
                    const theme = localStorage.getItem('theme');
                    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                    const isDark = theme === 'dark' || (!theme && prefersDark);
                    // Apply to the new document before it's swapped in
                    if (e.newDocument && e.newDocument.documentElement) {
                        if (isDark) {
                            e.newDocument.documentElement.classList.add('dark');
                        } else {
                            e.newDocument.documentElement.classList.remove('dark');
                        }
                    }
                });
            })();
        </script>
    </head>
    <body>
        <!-- Skip to main content link for accessibility -->
        <a href="#main-content" class="skip-link">
            {t('aria.skipToContent')}
        </a>

        <!-- Lifecycle Manager (must be first to handle View Transitions) -->
        <LifecycleInit />

        <!-- AutoAnimate Global -->
        <AutoAnimateGlobal />

        <!-- Smooth Scroll Integration -->
        <SmoothScroll client:only="react" />

        <!-- Build Search Index -->
        <BuildSearchIndex />

        <!-- Command Palette (Ctrl+K) -->
        <CommandPalette
            client:only="react"
            lang={lang}
            ariaLabel={t('aria.closeCommandPalette')}
            placeholder={t('aria.commandPalettePlaceholder')}
        />

        <!-- Scroll to Top Button -->
        <ScrollToTop client:load ariaLabel={t('aria.scrollToTop')} />

        <!-- View Transitions with Custom GSAP Animation -->
        <ViewTransitionGSAP />

        <Navigation />

        <main id="main-content" class="min-h-screen pt-14">
            <slot />
        </main>

        <!-- New Footer Component -->
        <Footer lang={lang} />

        <!-- Callout Enhancer for blog posts -->
        <!-- Transforms blockquotes with patterns like **Info:** into styled callouts -->
        <!-- Uses is:inline to ensure re-execution after View Transitions -->
        <!-- See: https://docs.astro.build/en/guides/view-transitions/#script-re-execution -->
        <script is:inline>
            (function() {
                // Guard to prevent duplicate event listener registration
                if (window.__calloutEnhancerInitialized) return;
                window.__calloutEnhancerInitialized = true;

                function enhanceCallouts() {
                    var calloutPatterns = {
                        info: /^<strong>Info:?<\/strong>:?\s*/i,
                        warning: /^<strong>Warning:?<\/strong>:?\s*/i,
                        tip: /^<strong>Tip:?<\/strong>:?\s*/i,
                        success: /^<strong>Success:?<\/strong>:?\s*/i,
                        error: /^<strong>Error:?<\/strong>:?\s*/i,
                        quote: /^<strong>Quote:?<\/strong>:?\s*/i
                    };

                    var blockquotes = document.querySelectorAll('.content-prose blockquote');

                    blockquotes.forEach(function(blockquote) {
                        if (blockquote.dataset.calloutEnhanced) return;

                        var firstParagraph = blockquote.querySelector('p');
                        if (!firstParagraph) return;

                        var html = firstParagraph.innerHTML.trim();

                        for (var type in calloutPatterns) {
                            var pattern = calloutPatterns[type];
                            if (pattern.test(html)) {
                                blockquote.dataset.calloutEnhanced = 'true';
                                blockquote.classList.add('callout-' + type);
                                var cleanedHtml = html.replace(pattern, '').trim();
                                firstParagraph.innerHTML = cleanedHtml;
                                if (!cleanedHtml) {
                                    firstParagraph.remove();
                                }
                                break;
                            }
                        }
                    });
                }

                // Run on initial page load
                enhanceCallouts();

                // Run after View Transitions content is ready
                // qazuor:content-ready is dispatched by ViewTransitionGSAP after DOM swap
                // This is the reliable way to enhance content when using custom GSAP transitions
                document.addEventListener('qazuor:content-ready', enhanceCallouts);
            })();
        </script>

        <!-- Vercel Analytics and Speed Insights -->
        <Analytics />
        <SpeedInsights />

        <!-- Global PixelCanvas Custom Element Registration -->
        <!-- Must be is:inline to work with View Transitions and always be available -->
        <script is:inline>
            (function() {
                // Guard to prevent duplicate registration
                if (window.__pixelCanvasGlobalInit) return;
                window.__pixelCanvasGlobalInit = true;

                // Pixel class for animation
                class Pixel {
                    constructor(canvas, context, x, y, color, speed, delay) {
                        this.width = canvas.width;
                        this.height = canvas.height;
                        this.ctx = context;
                        this.x = x;
                        this.y = y;
                        this.color = color;
                        this.speed = this._getRandomValue(0.1, 0.9) * speed;
                        this.size = 0;
                        this.sizeStep = Math.random() * 0.6;
                        this.minSize = 1;
                        this.maxSizeInteger = 4;
                        this.maxSize = this._getRandomValue(this.minSize, this.maxSizeInteger);
                        this.delay = delay;
                        this.counter = 0;
                        this.counterStep = Math.random() * 4 + (this.width + this.height) * 0.01;
                        this.isIdle = false;
                        this.isReverse = false;
                        this.isShimmer = false;
                    }

                    _getRandomValue(min, max) {
                        return Math.random() * (max - min) + min;
                    }

                    _draw() {
                        var centerOffset = this.maxSizeInteger * 0.5 - this.size * 0.5;
                        this.ctx.fillStyle = this.color;
                        this.ctx.fillRect(this.x + centerOffset, this.y + centerOffset, this.size, this.size);
                    }

                    appear() {
                        this.isIdle = false;
                        if (this.counter <= this.delay) {
                            this.counter += this.counterStep;
                            return;
                        }
                        if (this.size >= this.maxSize) {
                            this.isShimmer = true;
                        }
                        if (this.isShimmer) {
                            this._shimmer();
                        } else {
                            this.size += this.sizeStep;
                        }
                        this._draw();
                    }

                    disappear() {
                        this.isShimmer = false;
                        this.counter = 0;
                        if (this.size <= 0) {
                            this.isIdle = true;
                            return;
                        } else {
                            this.size -= 0.1;
                        }
                        this._draw();
                    }

                    _shimmer() {
                        if (this.size >= this.maxSize) {
                            this.isReverse = true;
                        } else if (this.size <= this.minSize) {
                            this.isReverse = false;
                        }
                        if (this.isReverse) {
                            this.size -= this.speed;
                        } else {
                            this.size += this.speed;
                        }
                    }
                }

                // PixelCanvas Custom Element
                class PixelCanvas extends HTMLElement {
                    static css = ':host { display: grid; inline-size: 100%; block-size: 100%; overflow: hidden; }';

                    constructor() {
                        super();
                        this._parent = null;
                        this.canvas = null;
                        this.ctx = null;
                        this.pixels = [];
                        this.animationFrame = 0;
                        this.timeInterval = 1000 / 60;
                        this.timePrevious = 0;
                        this.reducedMotion = false;
                        this.resizeObserver = null;
                        this.themeObserver = null;
                        this._debounceTimer = null;
                    }

                    get colorsDark() {
                        return this.dataset.colors ? this.dataset.colors.split(',').map(function(c) { return c.trim(); }) : ['#f8fafc', '#f1f5f9', '#cbd5e1'];
                    }

                    get colorsLight() {
                        return this.dataset.colorsLight ? this.dataset.colorsLight.split(',').map(function(c) { return c.trim(); }) : ['#1e293b', '#334155', '#475569'];
                    }

                    get colors() {
                        var isDark = document.documentElement.classList.contains('dark');
                        return isDark ? this.colorsDark : this.colorsLight;
                    }

                    get gap() {
                        var value = parseInt(this.dataset.gap || '5');
                        var min = 4;
                        var max = 50;
                        if (value <= min) return min;
                        if (value >= max) return max;
                        return value;
                    }

                    get speed() {
                        var value = parseInt(this.dataset.speed || '35');
                        var min = 0;
                        var max = 100;
                        var throttle = 0.001;
                        if (value <= min || this.reducedMotion) return min;
                        if (value >= max) return max * throttle;
                        return value * throttle;
                    }

                    get noFocus() {
                        return this.hasAttribute('data-no-focus');
                    }

                    connectedCallback() {
                        var self = this;
                        var canvas = document.createElement('canvas');
                        var sheet = new CSSStyleSheet();

                        this._parent = this.parentNode;
                        var shadowroot = this.attachShadow({ mode: 'open' });

                        sheet.replaceSync(PixelCanvas.css);

                        shadowroot.adoptedStyleSheets = [sheet];
                        shadowroot.append(canvas);
                        this.canvas = shadowroot.querySelector('canvas');
                        this.ctx = this.canvas ? this.canvas.getContext('2d') : null;
                        this.timeInterval = 1000 / 60;
                        this.timePrevious = performance.now();
                        this.reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

                        this.init();
                        this.resizeObserver = new ResizeObserver(function() { self.init(); });
                        this.resizeObserver.observe(this);

                        if (this._parent) {
                            this._parent.addEventListener('mouseenter', this);
                            this._parent.addEventListener('mouseleave', this);
                        }

                        if (!this.noFocus && this._parent) {
                            this._parent.addEventListener('focusin', this);
                            this._parent.addEventListener('focusout', this);
                        }

                        // Observe theme changes with debounce
                        this.themeObserver = new MutationObserver(function(mutations) {
                            for (var i = 0; i < mutations.length; i++) {
                                if (mutations[i].attributeName === 'class') {
                                    if (self._debounceTimer) clearTimeout(self._debounceTimer);
                                    self._debounceTimer = setTimeout(function() {
                                        self.init();
                                    }, 50);
                                }
                            }
                        });
                        this.themeObserver.observe(document.documentElement, { attributes: true });
                    }

                    disconnectedCallback() {
                        if (this.resizeObserver) this.resizeObserver.disconnect();
                        if (this.themeObserver) this.themeObserver.disconnect();
                        if (this._parent) {
                            this._parent.removeEventListener('mouseenter', this);
                            this._parent.removeEventListener('mouseleave', this);
                        }
                        if (!this.noFocus && this._parent) {
                            this._parent.removeEventListener('focusin', this);
                            this._parent.removeEventListener('focusout', this);
                        }
                        this._parent = null;
                    }

                    handleEvent(event) {
                        switch (event.type) {
                            case 'mouseenter': this._handleMouseEnter(); break;
                            case 'mouseleave': this._handleMouseLeave(); break;
                            case 'focusin': this._handleFocusIn(event); break;
                            case 'focusout': this._handleFocusOut(event); break;
                        }
                    }

                    _handleMouseEnter() { this._runAnimation('appear'); }
                    _handleMouseLeave() { this._runAnimation('disappear'); }

                    _handleFocusIn(e) {
                        var target = e.currentTarget;
                        if (target && target.contains(e.relatedTarget)) return;
                        this._runAnimation('appear');
                    }

                    _handleFocusOut(e) {
                        var target = e.currentTarget;
                        if (target && target.contains(e.relatedTarget)) return;
                        this._runAnimation('disappear');
                    }

                    _runAnimation(name) {
                        cancelAnimationFrame(this.animationFrame);
                        this.animationFrame = this._animatePixels(name);
                    }

                    init() {
                        if (!this.canvas || !this.ctx) return;
                        var rect = this.getBoundingClientRect();
                        var width = Math.floor(rect.width);
                        var height = Math.floor(rect.height);

                        this.pixels = [];
                        this.canvas.width = width;
                        this.canvas.height = height;
                        this.canvas.style.width = width + 'px';
                        this.canvas.style.height = height + 'px';
                        this._createPixels();
                    }

                    _getDistanceToCanvasCenter(x, y) {
                        if (!this.canvas) return 0;
                        var dx = x - this.canvas.width / 2;
                        var dy = y - this.canvas.height / 2;
                        return Math.sqrt(dx * dx + dy * dy);
                    }

                    _createPixels() {
                        if (!this.canvas || !this.ctx) return;
                        var maxDistance = Math.sqrt(
                            Math.pow(this.canvas.width / 2, 2) + Math.pow(this.canvas.height / 2, 2)
                        );

                        for (var x = 0; x < this.canvas.width; x += this.gap) {
                            for (var y = 0; y < this.canvas.height; y += this.gap) {
                                var distance = this._getDistanceToCanvasCenter(x, y);
                                var normalizedDistance = distance / maxDistance;
                                var skipChance = Math.pow(1 - normalizedDistance, 6) * 1.0;
                                if (Math.random() < skipChance) continue;

                                var color = this.colors[Math.floor(Math.random() * this.colors.length)];
                                var delay = this.reducedMotion ? 0 : distance;
                                this.pixels.push(new Pixel(this.canvas, this.ctx, x, y, color, this.speed, delay));
                            }
                        }
                    }

                    _animatePixels(fnName) {
                        var self = this;
                        this.animationFrame = requestAnimationFrame(function() { self._animatePixels(fnName); });

                        var timeNow = performance.now();
                        var timePassed = timeNow - this.timePrevious;

                        if (timePassed < this.timeInterval) return this.animationFrame;

                        this.timePrevious = timeNow - (timePassed % this.timeInterval);

                        if (!this.canvas || !this.ctx) return this.animationFrame;

                        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                        for (var i = 0; i < this.pixels.length; i++) {
                            this.pixels[i][fnName]();
                        }

                        var allIdle = true;
                        for (var j = 0; j < this.pixels.length; j++) {
                            if (!this.pixels[j].isIdle) {
                                allIdle = false;
                                break;
                            }
                        }
                        if (allIdle) {
                            cancelAnimationFrame(this.animationFrame);
                        }

                        return this.animationFrame;
                    }
                }

                // Register the custom element globally
                if (!customElements.get('pixel-canvas')) {
                    customElements.define('pixel-canvas', PixelCanvas);
                }

                // Initialize pixel-canvas elements (runs on page load and View Transitions)
                function initPixelCanvases() {
                    requestAnimationFrame(function() {
                        requestAnimationFrame(function() {
                            var pixelCanvases = document.querySelectorAll('pixel-canvas');
                            pixelCanvases.forEach(function(el) {
                                if (el.canvas && el.ctx) {
                                    el.init();
                                }
                            });
                        });
                    });
                }

                // Initialize on DOM ready
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', initPixelCanvases);
                } else {
                    initPixelCanvases();
                }

                // Re-initialize after View Transitions navigation
                document.addEventListener('qazuor:content-ready', initPixelCanvases);
            })();
        </script>
    </body>
</html>

<style is:global>
    @import '../styles/global.css';
</style>
