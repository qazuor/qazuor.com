---
/**
 * PageTransition Component - GSAP Implementation
 *
 * Creates smooth page transition effect with sliding overlay and animated page title.
 * Uses GSAP for animations and manual navigation handling.
 *
 * Features:
 * - Black overlay slides up from bottom with rounded wave border
 * - Page title appears with fade-in and slide-up animation
 * - Overlay slides up and out revealing new page
 * - Manual navigation with History API
 * - Handles edge cases (external links, anchor links, etc.)
 *
 * Inspired by: Dennis Snellenberg's portfolio transitions
 */
---

<!-- Transition overlay container (static HTML) -->
<div id="page-transition-overlay" class="page-transition-overlay" aria-hidden="true">
    <div class="page-transition-title" id="page-transition-title"></div>
</div>

<style>
    /* Overlay container - initially hidden below viewport */
    .page-transition-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #000;
        z-index: 9999;
        pointer-events: none;
        display: flex;
        align-items: center;
        justify-content: center;
        transform: translateY(100%);
        will-change: transform;
        overflow: hidden;
    }

    /* Wave-like rounded border at top */
    .page-transition-overlay::before {
        content: '';
        position: absolute;
        top: -80px;
        left: -10%;
        width: 120%;
        height: 150px;
        background-color: #000;
        border-radius: 0 0 50% 50% / 0 0 80px 80px;
        z-index: -1;
    }

    /* Wave-like rounded border at bottom */
    .page-transition-overlay::after {
        content: '';
        position: absolute;
        bottom: -80px;
        left: -10%;
        width: 120%;
        height: 150px;
        background-color: #000;
        border-radius: 50% 50% 0 0 / 80px 80px 0 0;
        z-index: -1;
    }

    /* Page title styling */
    .page-transition-title {
        font-size: clamp(2rem, 5vw, 4rem);
        font-weight: 700;
        color: #fff;
        text-align: center;
        opacity: 0;
        transform: translateY(20px);
        padding: 0 2rem;
        max-width: 90%;
        line-height: 1.2;
        font-family: 'Inter', system-ui, sans-serif;
        will-change: opacity, transform;
        z-index: 10;
        position: relative;
    }
</style>

<script>
    import { gsap } from 'gsap';

    /**
     * Page Transition System with GSAP + Manual Navigation
     */

    // Translations injected from server
    const translations = {
        en: {
            home: "Home",
            blog: "Blog",
            projects: "Projects",
            services: "Services",
            tools: "Tools",
            about: "About",
            skills: "Skills",
            testimonials: "Testimonials",
            contact: "Contact"
        },
        es: {
            home: "Inicio",
            blog: "Blog",
            projects: "Proyectos",
            services: "Servicios",
            tools: "Herramientas",
            about: "Acerca de",
            skills: "Habilidades",
            testimonials: "Testimonios",
            contact: "Contacto"
        }
    };

    // Configuration
    const TRANSITION_DURATION = 0.6; // seconds
    const TITLE_DELAY = 0.1; // Title appears very early (while overlay is sliding up)
    const PAUSE_DURATION = 0.3; // Shorter pause (300ms)
    const EASE = 'power4.inOut';

    // State
    let isNavigating = false;
    let currentRequest: AbortController | null = null;

    // Elements
    const overlay = document.getElementById('page-transition-overlay')!;
    const titleElement = document.getElementById('page-transition-title')!;

    /**
     * Extract page title from URL (path + hash) with i18n
     */
    function getPageTitleFromUrl(url: URL): string {
        // Extract locale from URL
        const pathSegments = url.pathname.split('/').filter(Boolean);
        const locale = (pathSegments[0] === 'en' || pathSegments[0] === 'es') ? pathSegments[0] : 'en';

        // Get translations for current locale
        const t = translations[locale];

        // If there's a hash, use it as the title
        if (url.hash) {
            let hashText = url.hash.substring(1); // Remove #

            // Replace 'hero' with 'home' for root navigation
            if (hashText === 'hero') {
                hashText = 'home';
            }

            // Try to find translation, fallback to formatted hash
            const translationKey = hashText.toLowerCase();
            return t[translationKey] || hashText
                .split('-')
                .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }

        // Get last segment of path (after locale)
        const pageSegment = pathSegments.length > 1 ? pathSegments[pathSegments.length - 1] : 'home';

        // Try to find translation
        const translationKey = pageSegment.toLowerCase();
        return t[translationKey] || pageSegment
            .split('-')
            .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' ');
    }

    /**
     * Check if URL is same origin
     */
    function isSameOrigin(url: string): boolean {
        try {
            const urlObj = new URL(url, window.location.origin);
            return urlObj.origin === window.location.origin;
        } catch {
            return false;
        }
    }

    /**
     * Check if link should be handled by transition system
     */
    function shouldHandleLink(link: HTMLAnchorElement): boolean {
        // Don't handle external links
        if (!isSameOrigin(link.href)) return false;

        // Don't handle links with target="_blank"
        if (link.target === '_blank') return false;

        // Don't handle links with download attribute
        if (link.hasAttribute('download')) return false;

        // Don't handle hash-only links on same page
        const currentUrl = new URL(window.location.href);
        const linkUrl = new URL(link.href);
        if (currentUrl.pathname === linkUrl.pathname && linkUrl.hash) {
            return false;
        }

        return true;
    }

    /**
     * Animate transition IN (overlay enters)
     */
    async function animateIn(toUrl: URL): Promise<void> {
        const pageTitle = getPageTitleFromUrl(toUrl);
        titleElement.textContent = pageTitle;

        const tl = gsap.timeline();

        // Overlay slides up from bottom
        tl.to(overlay, {
            y: 0,
            duration: TRANSITION_DURATION,
            ease: EASE
        });

        // Title fades in and slides up after overlay starts
        tl.to(
            titleElement,
            {
                opacity: 1,
                y: 0,
                duration: 0.4,
                ease: EASE
            },
            `+=${TITLE_DELAY}`
        );

        // Pause at top
        tl.to({}, { duration: PAUSE_DURATION });

        return tl.then();
    }

    /**
     * Animate transition OUT (overlay exits)
     */
    async function animateOut(): Promise<void> {
        const tl = gsap.timeline();

        // Title fades out and slides up
        tl.to(titleElement, {
            opacity: 0,
            y: -20,
            duration: 0.3,
            ease: EASE
        });

        // Overlay slides up out of view
        tl.to(
            overlay,
            {
                y: '-100%',
                duration: TRANSITION_DURATION,
                ease: EASE
            },
            '-=0.1'
        );

        // Reset for next transition
        tl.set(overlay, { y: '100%' });
        tl.set(titleElement, { opacity: 0, y: 20 });

        return tl.then();
    }

    /**
     * Fetch and parse new page
     */
    async function fetchPage(url: string): Promise<Document> {
        // Cancel any pending request
        if (currentRequest) {
            currentRequest.abort();
        }

        currentRequest = new AbortController();

        const response = await fetch(url, {
            signal: currentRequest.signal
        });

        if (!response.ok) {
            throw new Error(`Failed to fetch page: ${response.status}`);
        }

        const html = await response.text();
        const parser = new DOMParser();
        return parser.parseFromString(html, 'text/html');
    }

    /**
     * Update page content
     */
    function updatePage(newDoc: Document, targetUrl: URL): void {
        // Update title
        document.title = newDoc.title;

        // Update body classes
        document.body.className = newDoc.body.className;

        // Replace main content
        const oldMain = document.querySelector('main');
        const newMain = newDoc.querySelector('main');

        if (oldMain && newMain) {
            oldMain.replaceWith(newMain);
        }

        // Update meta tags
        const head = document.head;
        const newHead = newDoc.head;

        // Update meta description
        const metaDesc = head.querySelector('meta[name="description"]');
        const newMetaDesc = newHead.querySelector('meta[name="description"]');
        if (metaDesc && newMetaDesc) {
            metaDesc.setAttribute('content', newMetaDesc.getAttribute('content') || '');
        }

        // Dispatch event for other scripts (smooth scroll, etc)
        document.dispatchEvent(new Event('page-transition-complete'));

        // Handle hash navigation (scroll to element after page load)
        if (targetUrl.hash) {
            // Small delay to ensure DOM is ready and smooth scroll is initialized
            setTimeout(() => {
                const targetElement = document.querySelector(targetUrl.hash);
                if (targetElement) {
                    targetElement.scrollIntoView({ behavior: 'smooth' });
                }
            }, 150);
        }
    }

    /**
     * Navigate to new page
     */
    async function navigateTo(url: string): Promise<void> {
        if (isNavigating) return;

        const fromUrl = window.location.href;
        const toUrl = new URL(url, window.location.origin);

        // Don't navigate if it's the same page
        if (fromUrl === toUrl.href) return;

        isNavigating = true;

        try {
            // Run animation and page fetch in parallel
            const [_, newDoc] = await Promise.all([
                animateIn(toUrl),
                fetchPage(toUrl.href)
            ]);

            // Update page content
            updatePage(newDoc, toUrl);

            // Update browser history
            window.history.pushState({ url: toUrl.href }, '', toUrl.href);

            // Animate out
            await animateOut();
        } catch (error) {
            if ((error as Error).name === 'AbortError') {
                console.log('[PageTransition] Navigation aborted');
            } else {
                console.error('[PageTransition] Navigation error:', error);
                // Fallback to normal navigation
                window.location.href = url;
            }
        } finally {
            isNavigating = false;
            currentRequest = null;
        }
    }

    /**
     * Handle link clicks
     */
    function handleClick(e: MouseEvent): void {
        // Ignore modified clicks (ctrl, shift, meta, etc)
        if (e.ctrlKey || e.shiftKey || e.metaKey || e.altKey) return;

        // Ignore middle/right clicks
        if (e.button !== 0) return;

        const link = (e.target as HTMLElement).closest('a');
        if (!link || !shouldHandleLink(link)) return;

        e.preventDefault();
        navigateTo(link.href);
    }

    /**
     * Handle browser back/forward
     */
    function handlePopState(e: PopStateEvent): void {
        if (e.state?.url) {
            navigateTo(e.state.url);
        } else {
            navigateTo(window.location.href);
        }
    }

    /**
     * Handle custom navigate events (e.g., from LanguageSelector)
     */
    function handleNavigateEvent(e: Event): void {
        const customEvent = e as CustomEvent<{ url: string }>;
        if (customEvent.detail?.url) {
            navigateTo(customEvent.detail.url);
        }
    }

    /**
     * Initialize
     */
    function init(): void {
        // Set initial history state
        window.history.replaceState({ url: window.location.href }, '');

        // Add event listeners
        document.addEventListener('click', handleClick);
        window.addEventListener('popstate', handlePopState);
        window.addEventListener('navigate', handleNavigateEvent);

        console.log('[PageTransition] GSAP manual navigation initialized');
    }

    // Initialize on load
    init();
</script>
