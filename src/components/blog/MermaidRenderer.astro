---
/**
 * MermaidRenderer Component
 *
 * Lazy loads and renders Mermaid diagrams in blog posts.
 * Only included in blog post pages to avoid loading the library on other pages.
 *
 * Features:
 * - Lazy loads Mermaid library only when diagrams are present
 * - Supports theme switching (light/dark mode)
 * - Re-renders diagrams on theme change
 * - Click to open diagram in fullscreen modal
 */
---

<!-- Mermaid Lightbox Modal -->
<div id="mermaid-lightbox" class="mermaid-lightbox" aria-hidden="true" role="dialog" aria-modal="true" aria-label="Mermaid diagram fullscreen view">
    <button class="mermaid-lightbox-close" aria-label="Close fullscreen view" type="button">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
    </button>
    <div class="mermaid-lightbox-content"></div>
</div>

<style>
    .mermaid-lightbox {
        position: fixed;
        inset: 0;
        z-index: 9999;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
        padding: 2rem;
    }

    .mermaid-lightbox[aria-hidden="false"] {
        opacity: 1;
        visibility: visible;
    }

    .mermaid-lightbox-close {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 0.5rem;
        color: white;
        padding: 0.75rem;
        cursor: pointer;
        transition: background-color 0.2s ease;
        z-index: 10;
    }

    .mermaid-lightbox-close:hover {
        background: rgba(255, 255, 255, 0.2);
    }

    .mermaid-lightbox-content {
        width: 90vw;
        height: 85vh;
        overflow: auto;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #282a36; /* Same Dracula background as mermaid diagrams */
        border-radius: 0.75rem;
        padding: 2rem;
    }

    .mermaid-lightbox-content :global(svg) {
        /* Scale up the SVG to fill the container */
        min-width: 80vw;
        min-height: 70vh;
        width: auto;
        height: auto;
        max-width: none;
        max-height: none;
    }

    /* Clickable cursor on mermaid diagrams */
    :global(.mermaid-diagram) {
        cursor: zoom-in;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    :global(.mermaid-diagram:hover) {
        transform: scale(1.01);
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    }
</style>

<script type="module" is:inline>
    // Theme detection for Mermaid diagrams
    function getMermaidTheme() {
        return document.documentElement.classList.contains('dark') ? 'dark' : 'default';
    }

    function getMermaidThemeVariables() {
        // Read colors from CSS variables for theme consistency
        const style = getComputedStyle(document.documentElement);
        const primary = style.getPropertyValue('--mermaid-primary').trim();
        const secondary = style.getPropertyValue('--mermaid-secondary').trim();
        const background = style.getPropertyValue('--mermaid-background').trim();
        const border = style.getPropertyValue('--mermaid-border').trim();
        const text = style.getPropertyValue('--mermaid-text').trim();

        return {
            primaryColor: primary,
            primaryTextColor: text,
            primaryBorderColor: primary,
            lineColor: secondary,
            secondaryColor: background,
            tertiaryColor: border,
            background: background,
            mainBkg: background,
            secondaryBkg: border,
            textColor: text,
            fontSize: '16px',
            fontFamily: 'Inter, system-ui, sans-serif',
            edgeLabelBackground: background,
            labelBackground: background,
            labelColor: text
        };
    }

    // Extract code from a mermaid block - tries multiple methods
    function extractMermaidCode(pre, expressiveContainer) {
        // Method 1: From copy button data-code attribute
        const copyButton = expressiveContainer?.querySelector('.copy button[data-code]');
        if (copyButton) {
            const code = copyButton.getAttribute('data-code');
            if (code) return code;
        }

        // Method 2: From code element text content
        const codeElement = pre.querySelector('code');
        if (codeElement) {
            return codeElement.textContent || '';
        }

        // Method 3: Direct pre text content (fallback)
        return pre.textContent || '';
    }

    // Track if mermaid has been initialized to avoid duplicate event listeners
    let mermaidInitialized = false;

    // Mermaid initialization function
    async function initializeMermaid() {
        // Check for mermaid blocks FIRST (before loading library)
        const mermaidBlocks = document.querySelectorAll('pre[data-language="mermaid"]');

        // Exit early if no mermaid diagrams on page (saves ~548KB)
        if (mermaidBlocks.length === 0) return;

        try {
            // Only load mermaid when needed (reuse if already loaded)
            let mermaid = window.__mermaidInstance;

            if (!mermaid) {
                const mermaidModule = await import(
                    'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs'
                );
                mermaid = mermaidModule.default || mermaidModule;
                window.__mermaidInstance = mermaid;
            }

            // Initialize Mermaid with current theme
            mermaid.initialize({
                startOnLoad: false,
                theme: getMermaidTheme(),
                themeVariables: getMermaidThemeVariables(),
                flowchart: {
                    curve: 'basis',
                    lineWidth: 3,
                    padding: 20,
                    diagramPadding: 8,
                    htmlLabels: true,
                    rankSpacing: 50,
                    nodeSpacing: 50
                },
                securityLevel: 'loose'
            });

            // First, preserve expressive-code assets from the first block
            const firstExpressiveContainer = document.querySelector('.expressive-code');
            let expressiveCodeAssets = null;

            if (firstExpressiveContainer) {
                const linkTag = firstExpressiveContainer.querySelector('link[rel="stylesheet"]');
                const scriptTag = firstExpressiveContainer.querySelector('script[type="module"]');

                if (linkTag || scriptTag) {
                    expressiveCodeAssets = {
                        link: linkTag?.cloneNode(true),
                        script: scriptTag?.cloneNode(true)
                    };
                }
            }

            // Track containers to process
            const containersToProcess = [];

            mermaidBlocks.forEach((pre, index) => {
                const expressiveContainer = pre.closest('.expressive-code');
                let code = extractMermaidCode(pre, expressiveContainer);

                if (!code || code.trim() === '') return;

                // Fix expressive-code formatting
                code = code.replace(/    /g, '\n').replace(/\u007f/g, '\n');
                code = code.replace(/graph\s+(LR|RL)/gi, 'graph TD');
                code = code.replace(/flowchart\s+(LR|RL)/gi, 'flowchart TD');

                // Create mermaid container
                const container = document.createElement('div');
                container.className = 'expressive-code mermaid-diagram';

                // If this is the first mermaid block, preserve the assets
                if (index === 0 && expressiveCodeAssets) {
                    if (expressiveCodeAssets.link) {
                        container.appendChild(expressiveCodeAssets.link);
                    }
                    if (expressiveCodeAssets.script) {
                        container.appendChild(expressiveCodeAssets.script);
                    }
                }

                const figure = document.createElement('figure');
                figure.className = 'frame';

                const mermaidDiv = document.createElement('div');
                mermaidDiv.className = 'mermaid';
                mermaidDiv.textContent = code;

                figure.appendChild(mermaidDiv);
                container.appendChild(figure);

                containersToProcess.push({
                    target: expressiveContainer || pre,
                    replacement: container
                });
            });

            // Replace all containers
            containersToProcess.forEach(({ target, replacement }) => {
                target.replaceWith(replacement);
            });

            // Only proceed if we have diagrams to render
            if (containersToProcess.length === 0) return;

            // Render diagrams
            await mermaid.run();

            // Style edge labels using CSS variables
            const style = getComputedStyle(document.documentElement);
            const edgeFill = style.getPropertyValue('--mermaid-background').trim();
            const edgeStroke = style.getPropertyValue('--mermaid-primary').trim();

            document.querySelectorAll('.mermaid svg g.edgeLabel').forEach((label) => {
                const rect = label.querySelector('rect');
                if (rect) {
                    const currentWidth = parseFloat(rect.getAttribute('width') || '0');
                    const currentHeight = parseFloat(rect.getAttribute('height') || '0');
                    const currentX = parseFloat(rect.getAttribute('x') || '0');
                    const currentY = parseFloat(rect.getAttribute('y') || '0');

                    const padding = 8;
                    rect.setAttribute('width', String(currentWidth + padding * 2));
                    rect.setAttribute('height', String(currentHeight + padding * 2));
                    rect.setAttribute('x', String(currentX - padding));
                    rect.setAttribute('y', String(currentY - padding));
                    rect.setAttribute('rx', '4');
                    rect.setAttribute('ry', '4');
                    rect.setAttribute('fill', edgeFill);
                    rect.setAttribute('stroke', edgeStroke);
                    rect.setAttribute('stroke-width', '1');
                }
            });

            // Re-initialize lightbox after rendering
            initMermaidLightbox();
        } catch (error) {
            console.error('Mermaid failed to load:', error);
        }
    }

    // Debounced initialization to handle rapid navigations
    let initTimeout = null;
    function debouncedInit() {
        if (initTimeout) clearTimeout(initTimeout);
        initTimeout = setTimeout(initializeMermaid, 50);
    }

    // Initialize on initial page load
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeMermaid);
    } else {
        initializeMermaid();
    }

    // Re-initialize after View Transitions navigation
    // Listen to both custom event and Astro's official event for better compatibility
    if (!mermaidInitialized) {
        document.addEventListener('qazuor:content-ready', debouncedInit);
        document.addEventListener('astro:page-load', debouncedInit);
        mermaidInitialized = true;
    }

    // Re-render diagrams on theme change
    document.addEventListener('theme-changed', async () => {
        const mermaid = window.__mermaidInstance;
        if (!mermaid) return;

        const mermaidContainers = document.querySelectorAll('.mermaid-diagram');
        if (mermaidContainers.length === 0) return;

        // Re-initialize with new theme
        mermaid.initialize({
            startOnLoad: false,
            theme: getMermaidTheme(),
            themeVariables: getMermaidThemeVariables(),
            flowchart: {
                curve: 'basis',
                lineWidth: 3,
                padding: 20,
                diagramPadding: 8,
                htmlLabels: true,
                rankSpacing: 50,
                nodeSpacing: 50
            },
            securityLevel: 'loose'
        });

        // Re-run mermaid on existing diagrams
        try {
            await mermaid.run();
        } catch (err) {
            console.error('Mermaid re-render failed:', err);
        }
    });

    // Mermaid Lightbox functionality
    // Track attached listeners to avoid duplicates
    const lightboxListeners = new WeakSet();

    function initMermaidLightbox() {
        const lightbox = document.getElementById('mermaid-lightbox');
        const lightboxContent = lightbox?.querySelector('.mermaid-lightbox-content');
        const closeButton = lightbox?.querySelector('.mermaid-lightbox-close');

        if (!lightbox || !lightboxContent || !closeButton) return;

        // Close lightbox function
        function closeLightbox() {
            lightbox.setAttribute('aria-hidden', 'true');
            document.body.style.overflow = '';
        }

        // Open lightbox when clicking on a mermaid diagram
        document.querySelectorAll('.mermaid-diagram').forEach((diagram) => {
            // Skip if already has listener
            if (lightboxListeners.has(diagram)) return;
            lightboxListeners.add(diagram);

            diagram.addEventListener('click', () => {
                const svg = diagram.querySelector('.mermaid svg');
                if (svg) {
                    // Clone the SVG to show in lightbox
                    const svgClone = svg.cloneNode(true);
                    lightboxContent.innerHTML = '';
                    lightboxContent.appendChild(svgClone);
                    lightbox.setAttribute('aria-hidden', 'false');
                    document.body.style.overflow = 'hidden';
                }
            });
        });

        // Only attach close button listener once
        if (!lightboxListeners.has(closeButton)) {
            lightboxListeners.add(closeButton);
            closeButton.addEventListener('click', closeLightbox);
        }

        // Only attach lightbox backdrop listener once
        if (!lightboxListeners.has(lightbox)) {
            lightboxListeners.add(lightbox);

            // Close on click outside content
            lightbox.addEventListener('click', (e) => {
                if (e.target === lightbox) {
                    closeLightbox();
                }
            });

            // Close on Escape key (use document with check)
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && lightbox.getAttribute('aria-hidden') === 'false') {
                    closeLightbox();
                }
            });
        }
    }

    // Initial lightbox setup (called from initializeMermaid after rendering)
    // No need for separate initialization - it's called at the end of initializeMermaid()
</script>
