---
/**
 * ViewTransition Component - Production Implementation
 *
 * Integrates Astro View Transitions with custom CSS/JS animations.
 * Uses native Web Animations API for zero dependencies.
 * Maintains the exact design and timing of the original PageTransition.astro
 * but fixes script execution issues by leveraging Astro's built-in system.
 *
 * Features:
 * - Black overlay slides up from bottom with rounded wave border
 * - Page title appears with fade-in and slide-up animation
 * - DOM swap happens invisibly behind overlay
 * - Overlay slides up and out revealing new page
 * - All scripts re-execute automatically via View Transitions
 *
 * Technical:
 * - Uses event.swap override for full timing control
 * - Uses transition:persist to maintain overlay across navigations
 * - Identical animation to original (0.6s + 0.4s + 0.3s = 1.3s total)
 * - Page titles map generated at build time from Content Collections
 */
import type { CollectionEntry } from 'astro:content';
import { getCollection } from 'astro:content';
import SectionTitle from '@/components/ui/SectionTitle.astro';
import { languages } from '@/i18n/ui';
import { getTranslations } from '@/i18n/utils';
import { getEffectiveSlug } from '@/utils/blog';
import { getProjectSlug } from '@/utils/projects';

// Generate page titles map at build time
const pageTitles: Record<string, string> = {};
const paginationTranslations: Record<string, { blogTitle: string; pageLabel: string }> = {};
const langs = Object.keys(languages) as Array<'en' | 'es'>;

// 1. Static pages from translations
for (const lang of langs) {
    const t = getTranslations(lang);
    const nav = {
        home: t('nav.home'),
        blog: t('nav.blog'),
        projects: t('nav.projects'),
        services: t('nav.services'),
        tools: t('nav.tools'),
        about: t('nav.about'),
        skills: t('nav.skills'),
        testimonials: t('nav.testimonials'),
        contact: t('nav.contact')
    };

    // Store pagination translations for client-side use
    paginationTranslations[lang] = {
        blogTitle: nav.blog,
        pageLabel: t('blog.pagination.page')
    };

    // Root and section pages
    pageTitles[`/${lang}`] = nav.home;
    pageTitles[`/${lang}/blog`] = nav.blog;
    pageTitles[`/${lang}/projects`] = nav.projects;
    pageTitles[`/${lang}/services`] = nav.services;
    pageTitles[`/${lang}/goodies`] = nav.tools;

    // Hash sections (for single-page navigation)
    pageTitles[`/${lang}#hero`] = nav.home;
    pageTitles[`/${lang}#about`] = nav.about;
    pageTitles[`/${lang}#skills`] = nav.skills;
    pageTitles[`/${lang}#services`] = nav.services;
    pageTitles[`/${lang}#projects`] = nav.projects;
    pageTitles[`/${lang}#testimonials`] = nav.testimonials;
    pageTitles[`/${lang}#contact`] = nav.contact;
}

// 2. Blog posts from Content Collection
const blogs = await getCollection('blog', (entry: CollectionEntry<'blog'>) => !entry.data.draft);
for (const post of blogs) {
    for (const lang of langs) {
        pageTitles[`/${lang}/blog/${getEffectiveSlug(post)}`] = post.data.title;
    }
}

// 3. Tools from Content Collection
const tools = await getCollection('tools');
for (const tool of tools) {
    for (const lang of langs) {
        pageTitles[`/${lang}/goodies/${tool.slug}`] = tool.data.title;
    }
}

// 4. Projects from Content Collection
const projects = await getCollection('projects');
for (const project of projects) {
    const projectLang = project.data.lang;
    const cleanSlug = getProjectSlug(project);
    pageTitles[`/${projectLang}/projects/${cleanSlug}`] = project.data.title;
}
---

<!-- Transition overlay container with transition:persist -->
<div
    id="page-transition-overlay"
    transition:persist="page-transition-overlay"
    class="page-transition-overlay"
    aria-hidden="true"
>
    <!-- Wave border at top -->
    <div class="wave-top">
        <svg class="w-full h-32 md:h-40" viewBox="0 0 1200 120" preserveAspectRatio="none">
            <path
                d="M0,120 L0,0 C150,80 300,30 450,60 C600,90 750,40 900,70 C1050,100 1150,50 1200,0 L1200,120 Z"
                fill="#000"
                fill-opacity="0.3"
            >
                <animate
                    attributeName="d"
                    dur="10s"
                    repeatCount="indefinite"
                    values="
                        M0,120 L0,0 C150,80 300,30 450,60 C600,90 750,40 900,70 C1050,100 1150,50 1200,0 L1200,120 Z;
                        M0,120 L0,40 C150,20 300,70 450,30 C600,50 750,80 900,40 C1050,60 1150,90 1200,40 L1200,120 Z;
                        M0,120 L0,20 C150,60 300,10 450,50 C600,30 750,70 900,50 C1050,80 1150,60 1200,20 L1200,120 Z;
                        M0,120 L0,0 C150,80 300,30 450,60 C600,90 750,40 900,70 C1050,100 1150,50 1200,0 L1200,120 Z
                    "
                ></animate>
            </path>
            <path
                d="M0,120 L0,20 C200,70 400,30 600,60 C800,90 1000,40 1200,20 L1200,120 Z"
                fill="#000"
                fill-opacity="0.5"
            >
                <animate
                    attributeName="d"
                    dur="8s"
                    repeatCount="indefinite"
                    values="
                        M0,120 L0,20 C200,70 400,30 600,60 C800,90 1000,40 1200,20 L1200,120 Z;
                        M0,120 L0,50 C200,30 400,70 600,40 C800,20 1000,80 1200,50 L1200,120 Z;
                        M0,120 L0,35 C200,55 400,20 600,50 C800,45 1000,65 1200,35 L1200,120 Z;
                        M0,120 L0,20 C200,70 400,30 600,60 C800,90 1000,40 1200,20 L1200,120 Z
                    "
                ></animate>
            </path>
            <path
                d="M0,120 L0,40 C120,60 240,35 360,50 C480,65 600,40 720,55 C840,70 960,45 1080,60 C1150,70 1180,50 1200,40 L1200,120 Z"
                fill="#000"
            >
                <animate
                    attributeName="d"
                    dur="6s"
                    repeatCount="indefinite"
                    values="
                        M0,120 L0,40 C120,60 240,35 360,50 C480,65 600,40 720,55 C840,70 960,45 1080,60 C1150,70 1180,50 1200,40 L1200,120 Z;
                        M0,120 L0,60 C120,35 240,60 360,40 C480,50 600,65 720,45 C840,55 960,70 1080,50 C1150,55 1180,70 1200,60 L1200,120 Z;
                        M0,120 L0,50 C120,45 240,50 360,35 C480,55 600,50 720,40 C840,60 960,55 1080,45 C1150,60 1180,55 1200,50 L1200,120 Z;
                        M0,120 L0,40 C120,60 240,35 360,50 C480,65 600,40 720,55 C840,70 960,45 1080,60 C1150,70 1180,50 1200,40 L1200,120 Z
                    "
                ></animate>
            </path>
        </svg>
    </div>

    <!-- Title in center -->
    <div
        id="page-transition-title"
        transition:persist="page-transition-title"
        class="page-transition-title"
    >
        <SectionTitle title="" size="2xl" showGradient={true} customElement="h1" />
    </div>

    <!-- Wave border at bottom -->
    <div class="wave-bottom">
        <svg class="w-full h-32 md:h-40" viewBox="0 0 1200 120" preserveAspectRatio="none">
            <path
                d="M0,0 L0,120 C150,40 300,90 450,60 C600,30 750,80 900,50 C1050,20 1150,70 1200,120 L1200,0 Z"
                fill="#000"
                fill-opacity="0.3"
            >
                <animate
                    attributeName="d"
                    dur="10s"
                    repeatCount="indefinite"
                    values="
                        M0,0 L0,120 C150,40 300,90 450,60 C600,30 750,80 900,50 C1050,20 1150,70 1200,120 L1200,0 Z;
                        M0,0 L0,80 C150,100 300,50 450,90 C600,70 750,40 900,80 C1050,60 1150,30 1200,80 L1200,0 Z;
                        M0,0 L0,100 C150,60 300,110 450,70 C600,50 750,100 900,60 C1050,40 1150,90 1200,100 L1200,0 Z;
                        M0,0 L0,120 C150,40 300,90 450,60 C600,30 750,80 900,50 C1050,20 1150,70 1200,120 L1200,0 Z
                    "
                ></animate>
            </path>
            <path
                d="M0,0 L0,100 C200,50 400,90 600,70 C800,40 1000,80 1200,100 L1200,0 Z"
                fill="#000"
                fill-opacity="0.5"
            >
                <animate
                    attributeName="d"
                    dur="8s"
                    repeatCount="indefinite"
                    values="
                        M0,0 L0,100 C200,50 400,90 600,70 C800,40 1000,80 1200,100 L1200,0 Z;
                        M0,0 L0,70 C200,90 400,50 600,80 C800,70 1000,40 1200,70 L1200,0 Z;
                        M0,0 L0,85 C200,65 400,100 600,60 C800,55 1000,95 1200,85 L1200,0 Z;
                        M0,0 L0,100 C200,50 400,90 600,70 C800,40 1000,80 1200,100 L1200,0 Z
                    "
                ></animate>
            </path>
            <path
                d="M0,0 L0,80 C120,60 240,85 360,70 C480,55 600,80 720,65 C840,50 960,75 1080,60 C1150,50 1180,70 1200,80 L1200,0 Z"
                fill="#000"
            >
                <animate
                    attributeName="d"
                    dur="6s"
                    repeatCount="indefinite"
                    values="
                        M0,0 L0,80 C120,60 240,85 360,70 C480,55 600,80 720,65 C840,50 960,75 1080,60 C1150,50 1180,70 1200,80 L1200,0 Z;
                        M0,0 L0,60 C120,85 240,60 360,80 C480,70 600,55 720,75 C840,65 960,50 1080,70 C1150,65 1180,50 1200,60 L1200,0 Z;
                        M0,0 L0,70 C120,75 240,70 360,85 C480,65 600,70 720,80 C840,60 960,65 1080,75 C1150,60 1180,65 1200,70 L1200,0 Z;
                        M0,0 L0,80 C120,60 240,85 360,70 C480,55 600,80 720,65 C840,50 960,75 1080,60 C1150,50 1180,70 1200,80 L1200,0 Z
                    "
                ></animate>
            </path>
        </svg>
    </div>
</div>

<style>
    /* Overlay container - initially hidden below viewport and invisible */
    .page-transition-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #000;
        z-index: 9999;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        transform: translateY(115%);
        will-change: transform;
        overflow: visible;
        visibility: hidden; /* Hide from accessibility tree when not in use */
    }

    /* Wave at top - positioned at the edge of the overlay */
    .wave-top {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        z-index: 1;
        transform: translateY(-100%);
    }

    /* Wave at bottom - positioned at the edge of the overlay */
    .wave-bottom {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        z-index: 1;
        transform: translateY(100%);
    }

    /* Page title styling - wrapper for SectionTitle component */
    .page-transition-title {
        opacity: 0;
        transform: translateY(20px);
        padding: 0 2rem;
        max-width: 90%;
        will-change: opacity, transform;
        z-index: 10;
        position: relative;
    }

    /* Override SectionTitle styles for transition overlay */
    .page-transition-title :global(.section-title) {
        margin-bottom: 0;
    }

    /* Dynamic font sizing - adapts to viewport and text length */
    .page-transition-title :global(h1) {
        /* Override fixed size with responsive clamp */
        /* Min: 1.5rem (24px), Preferred: 8vw, Max: 4.5rem (72px) */
        font-size: clamp(1.5rem, 8vw, 4.5rem) !important;
        line-height: 1.1;
        text-wrap: balance;
        word-break: break-word;
        hyphens: auto;
    }

    /* Even smaller on very small screens */
    @media (max-width: 480px) {
        .page-transition-title :global(h1) {
            font-size: clamp(1.25rem, 7vw, 2.5rem) !important;
        }
    }

</style>

<style is:global>
    /* Disable default View Transitions animations */
    ::view-transition-old(root),
    ::view-transition-new(root) {
        animation: none !important;
        mix-blend-mode: normal;
    }

    /* Make view transition instant */
    ::view-transition-group(root) {
        animation-duration: 0s !important;
    }
</style>

<!-- Inject page titles map generated at build time -->
<script is:inline define:vars={{ pageTitles, paginationTranslations }}>
    window.__PAGE_TITLES__ = pageTitles;
    window.__PAGINATION_TRANSLATIONS__ = paginationTranslations;
</script>

<script>
    /**
     * ViewTransition Animation - Vanilla JS Implementation
     * Replaces GSAP with native Web Animations API for zero dependencies
     */

    // Animation configuration
    const TRANSITION_DURATION = 1000; // ms - Overlay slide duration
    const TITLE_DURATION = 400; // ms - Title fade duration
    const PAUSE_DURATION = 100; // ms - Brief pause at peak
    const EASE = 'cubic-bezier(0.86, 0, 0.07, 1)'; // Equivalent to GSAP power4.inOut

    // DOM elements
    const overlay = document.getElementById('page-transition-overlay')!;
    const titleElement = document.getElementById('page-transition-title')!;

    // Promise for entrance animation (shared between hooks)
    let entrancePromise: Promise<void> | null = null;

    // Track the pathname of the last rendered page (not window.location which changes on popstate)
    // This is critical for back/forward navigation - during popstate, window.location changes
    // BEFORE astro:before-preparation fires, so we need to track the actual rendered content
    let lastRenderedPath = normalizePathname(window.location.pathname);

    /**
     * Normalize pathname by removing trailing slash for comparison
     */
    function normalizePathname(pathname: string): string {
        return pathname.endsWith('/') && pathname.length > 1 ? pathname.slice(0, -1) : pathname;
    }

    /**
     * Get page title from URL using the build-time generated map
     */
    function getPageTitle(url: URL): string {
        const titles = (window as any).__PAGE_TITLES__ || {};
        const paginationTrans = (window as any).__PAGINATION_TRANSLATIONS__ || {};
        const normalizedPath = normalizePathname(url.pathname);

        // Try exact match with hash first
        if (url.hash) {
            const pathWithHash = `${normalizedPath}${url.hash}`;
            if (titles[pathWithHash]) {
                return titles[pathWithHash];
            }
        }

        // Try exact path match
        if (titles[normalizedPath]) {
            return titles[normalizedPath];
        }

        // Check for blog pagination pattern: /{lang}/blog/{pageNumber}
        const blogPaginationMatch = normalizedPath.match(/^\/(en|es)\/blog\/(\d+)$/);
        if (blogPaginationMatch) {
            const lang = blogPaginationMatch[1];
            const pageNum = blogPaginationMatch[2];
            const trans = paginationTrans[lang];
            if (trans) {
                return `${trans.blogTitle} - ${trans.pageLabel} ${pageNum}`;
            }
        }

        // Fallback: extract last segment and capitalize
        const segments = normalizedPath.split('/').filter(Boolean);
        const lastSegment = segments[segments.length - 1] || 'home';
        return lastSegment.charAt(0).toUpperCase() + lastSegment.slice(1).replace(/-/g, ' ');
    }

    /**
     * Animate entrance - overlay slides up, title fades in
     */
    async function animateEntrance(): Promise<void> {
        // Make overlay visible
        overlay.style.visibility = 'visible';

        // Overlay slides up from bottom (translateY(115%) -> translateY(0))
        const overlayAnim = overlay.animate(
            [
                { transform: 'translateY(115%)' },
                { transform: 'translateY(0)' }
            ],
            {
                duration: TRANSITION_DURATION,
                easing: EASE,
                fill: 'forwards'
            }
        );

        await overlayAnim.finished;

        // Title fades in and slides up
        const titleAnim = titleElement.animate(
            [
                { opacity: 0, transform: 'translateY(20px)' },
                { opacity: 1, transform: 'translateY(0)' }
            ],
            {
                duration: TITLE_DURATION,
                easing: EASE,
                fill: 'forwards'
            }
        );

        await titleAnim.finished;

        // Brief pause at peak
        await new Promise<void>(resolve => setTimeout(resolve, PAUSE_DURATION));
    }

    /**
     * Animate exit - title fades out, overlay slides up and out
     */
    async function animateExit(): Promise<void> {
        // Title fades out and slides up
        const titleAnim = titleElement.animate(
            [
                { opacity: 1, transform: 'translateY(0)' },
                { opacity: 0, transform: 'translateY(-20px)' }
            ],
            {
                duration: 300,
                easing: EASE,
                fill: 'forwards'
            }
        );

        // Start overlay exit with slight overlap (-=0.1s = 100ms early)
        await new Promise<void>(resolve => setTimeout(resolve, 200));

        // Overlay slides up out of view
        const overlayAnim = overlay.animate(
            [
                { transform: 'translateY(0)' },
                { transform: 'translateY(-115%)' }
            ],
            {
                duration: TRANSITION_DURATION,
                easing: EASE,
                fill: 'forwards'
            }
        );

        // Wait for both animations to complete
        await Promise.all([titleAnim.finished, overlayAnim.finished]);

        // Reset for next transition
        overlay.style.transform = 'translateY(115%)';
        overlay.style.visibility = 'hidden';
        titleElement.style.opacity = '0';
        titleElement.style.transform = 'translateY(20px)';
    }

    /**
     * HOOK 1: Before preparation - Start entrance animation IMMEDIATELY
     * This fires as soon as user clicks a link (before fetch)
     */
    document.addEventListener('astro:before-preparation', ((event: any) => {
        const newUrl = new URL(event.to);

        // Skip animation if pathname doesn't change (same-page hash navigation)
        // When pathname is the same, Astro only scrolls and doesn't trigger swap
        // This prevents the animation from getting stuck
        // IMPORTANT: Use lastRenderedPath instead of window.location.pathname
        // During popstate (back/forward), window.location already changed to the destination
        // so comparing window.location vs event.to would always be "same page"
        const newPath = normalizePathname(newUrl.pathname);
        const isSamePage = lastRenderedPath === newPath;

        if (isSamePage) {
            // Prevent Astro from handling this navigation with View Transitions
            // Let Navigation.astro handle the smooth scroll instead
            event.preventDefault();
            return;
        }

        const pageTitle = getPageTitle(newUrl);

        // Update the SectionTitle component text
        const gradientTextElement = titleElement.querySelector('.gradient-text-section');
        if (gradientTextElement) {
            gradientTextElement.textContent = pageTitle;
        }

        // Start entrance animation immediately (store promise, don't await here)
        entrancePromise = animateEntrance();
    }) as EventListener);

    /**
     * HOOK 2: Before swap - Wait for entrance, swap, then exit
     */
    document.addEventListener('astro:before-swap', ((event: any) => {
        const originalSwap = event.swap;

        event.swap = async () => {
            // STEP 1: Wait for entrance animation to complete
            if (entrancePromise) {
                await entrancePromise;
                entrancePromise = null;
            }

            // STEP 2: Perform DOM swap (invisible behind overlay)
            await originalSwap();

            // STEP 2.5: Dispatch custom event for content enhancement scripts
            // This fires after DOM swap but before exit animation starts
            // Components like CalloutEnhancer can listen for this to process new content
            document.dispatchEvent(new CustomEvent('qazuor:content-ready'));

            // STEP 3: Animate OUT (reveals new content)
            await animateExit();
        };
    }) as EventListener);

    /**
     * HOOK 3: After swap - Update lastRenderedPath to track actual rendered content
     * This is critical for back/forward navigation to work correctly
     */
    document.addEventListener('astro:after-swap', () => {
        lastRenderedPath = normalizePathname(window.location.pathname);
    });

    /**
     * HOOK 4: Popstate fallback for browsers without native View Transitions
     * Firefox and other browsers may not trigger astro:before-preparation on popstate
     * This handler detects when the rendered content differs from the target URL
     * and forces a proper navigation with View Transitions using Astro's navigate()
     */
    window.addEventListener('popstate', async () => {
        const targetPath = normalizePathname(window.location.pathname);

        // If the actual rendered content is different from where we're navigating to,
        // Astro didn't handle the navigation - we need to force it
        if (lastRenderedPath !== targetPath) {
            // Import navigate dynamically to avoid issues with SSR
            const { navigate } = await import('astro:transitions/client');

            // Force navigation with View Transitions
            // Use history: 'replace' since the URL is already updated by popstate
            navigate(window.location.href, { history: 'replace' });
        }
    });
</script>
