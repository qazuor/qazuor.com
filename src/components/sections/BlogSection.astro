---
import { getImage } from 'astro:assets';
import { getCollection } from 'astro:content';
import type { ImageMetadata } from 'astro';
import FeaturedBlogCard from '@/components/cards/FeaturedBlogCard.astro';
import type { SecondaryBlogPost } from '@/components/cards/SecondaryBlogCards.astro';
import SecondaryBlogCards from '@/components/cards/SecondaryBlogCards.astro';
import AnimatedGradientBackground from '@/components/ui/AnimatedGradientBackground.astro';
import SectionTitle from '@/components/ui/SectionTitle.astro';
import UnifiedButton from '@/components/ui/UnifiedButton.astro';
import fallbackProgramming from '@/content/blog/_images/code-typescript.jpg';
import fallbackFrontend from '@/content/blog/_images/react-frontend.jpg';
// Static imports for fallback images by category
import fallbackDefault from '@/content/blog/_images/web-development.jpg';
import fallbackWebdev from '@/content/blog/_images/web-development.jpg';
import { getCategoryBgColor, getSecondaryCardColor } from '@/data/categoryColors';
import { processMarkdown } from '@/i18n/utils';
import DocumentEmptyIcon from '@/icons/ui/document-empty.svg?raw';

interface BlogPost {
    title: string;
    excerpt: string;
    date: string;
    readTime: string;
    tags: string[];
    slug: string;
    featured?: boolean;
}

interface Props {
    posts: BlogPost[];
    primaryColor?: string;
    translations: {
        title: string;
        subtitle: string;
        description?: string;
        viewAll: string;
        noArticles: string;
        readMore: string;
        readTime: string;
        featured?: string;
        categories?: Record<string, string>;
    };
    lang: string;
}

const { posts, primaryColor = 'var(--section-blog-bg)', translations, lang } = Astro.props;

// Helper to translate category
function translateCategory(category: string): string {
    return translations.categories?.[category] || category;
}

// Helper to format readTime with translated label
// Input: "30 min read" -> Output: "30 min de lectura" (for Spanish)
function formatReadTime(readTime: string): string {
    const match = readTime.match(/^(\d+)/);
    if (match) {
        return `${match[1]} ${translations.readTime}`;
    }
    return readTime;
}

// Get full blog collection with images
const allBlogPosts = await getCollection('blog');

// Category fallback mapping (using static imports)
// Keys are the centralized category keys from blogCategories.ts
const categoryFallbacks: Record<string, ImageMetadata> = {
    // Category keys
    frontend: fallbackFrontend,
    productivity: fallbackWebdev,
    development: fallbackProgramming,
    architecture: fallbackProgramming,
    performance: fallbackWebdev,
    product: fallbackWebdev,
    business: fallbackWebdev,
    general: fallbackDefault,
    // Additional fallbacks for common tags
    javascript: fallbackFrontend,
    typescript: fallbackFrontend,
    react: fallbackFrontend,
    astro: fallbackFrontend,
    css: fallbackFrontend,
    design: fallbackFrontend
};

// Blog card image dimensions (16:9 aspect ratio for featured card)
const BLOG_IMAGE_WIDTH = 600;
const BLOG_IMAGE_HEIGHT = 400;

// Find featured post: first with featured=true, or most recent
const featuredPostData = posts.find((p) => p.featured) || posts[0];

// Secondary posts: next 5 after featured
const secondaryPostsData = posts.filter((p) => p.slug !== featuredPostData?.slug).slice(0, 5);

// Process featured post with image
let featuredPost = null;
if (featuredPostData) {
    const fullPost = allBlogPosts.find((p: { slug: string }) => `/${lang}/blog/${p.slug}` === featuredPostData.slug);
    const category = fullPost?.data.category || featuredPostData.tags[0] || 'Article';

    let optimizedImage = { src: '', width: BLOG_IMAGE_WIDTH, height: BLOG_IMAGE_HEIGHT };

    // Try to use post image first
    if (fullPost?.data.image) {
        try {
            const img = await getImage({
                src: fullPost.data.image as ImageMetadata,
                width: BLOG_IMAGE_WIDTH,
                height: BLOG_IMAGE_HEIGHT,
                format: 'webp'
            });
            optimizedImage = { src: img.src, width: BLOG_IMAGE_WIDTH, height: BLOG_IMAGE_HEIGHT };
        } catch (error) {
            console.warn(`Failed to optimize image for ${featuredPostData.slug}:`, error);
        }
    }

    // Fallback to category placeholder
    if (!optimizedImage.src) {
        const fallbackImageSrc = categoryFallbacks[category] || fallbackDefault;
        try {
            const img = await getImage({
                src: fallbackImageSrc,
                width: BLOG_IMAGE_WIDTH,
                height: BLOG_IMAGE_HEIGHT,
                format: 'webp'
            });
            optimizedImage = { src: img.src, width: BLOG_IMAGE_WIDTH, height: BLOG_IMAGE_HEIGHT };
        } catch (error) {
            console.warn(`Failed to load placeholder for category ${category}:`, error);
            optimizedImage = { src: '/placeholder.jpg', width: BLOG_IMAGE_WIDTH, height: BLOG_IMAGE_HEIGHT };
        }
    }

    featuredPost = {
        ...featuredPostData,
        image: optimizedImage,
        category: translateCategory(category),
        categoryColor: getCategoryBgColor(category),
        readTime: formatReadTime(featuredPostData.readTime)
    };
}

// Process secondary posts (no images needed)
const secondaryPosts: SecondaryBlogPost[] = secondaryPostsData.map((post, index) => {
    const fullPost = allBlogPosts.find((p: { slug: string }) => `/${lang}/blog/${p.slug}` === post.slug);
    const category = fullPost?.data.category || post.tags[0] || 'Article';

    return {
        title: post.title,
        excerpt: processMarkdown(post.excerpt),
        category: translateCategory(category),
        slug: post.slug,
        tags: post.tags,
        readTime: formatReadTime(post.readTime),
        date: post.date,
        borderColor: getSecondaryCardColor(index)
    };
});
---

<section
    class="relative section section-purple-blue overflow-hidden"
    id="blog"
    style={`background-color: ${primaryColor}`}
>
    <!-- Animated Gradient Background -->
    <AnimatedGradientBackground />

    <div class="container-custom">
        <!-- Section Title -->
        <SectionTitle
            title={translations.title}
            subtitle={translations.subtitle}
            description={translations.description}
            descriptionClassName="!text-base !max-w-3xl mx-auto mt-6 leading-relaxed"
        />

        <!-- Blog Content -->
        {
            posts.length > 0 ? (
                <div class="blog-new-layout space-y-8">
                    {/* Featured Post */}
                    {featuredPost && (
                        <FeaturedBlogCard
                            title={featuredPost.title}
                            excerpt={processMarkdown(featuredPost.excerpt)}
                            category={featuredPost.category}
                            image={featuredPost.image}
                            slug={featuredPost.slug}
                            tags={featuredPost.tags}
                            readTime={featuredPost.readTime}
                            date={featuredPost.date}
                            categoryColor={featuredPost.categoryColor}
                            featuredLabel={translations.featured || 'Featured'}
                            lang={lang}
                        />
                    )}

                    {/* Secondary Posts */}
                    {secondaryPosts.length > 0 && (
                        <SecondaryBlogCards posts={secondaryPosts} lang={lang} />
                    )}

                    {/* View All Button */}
                    {posts.length > 6 && (
                        <div class="text-center pt-8">
                            <UnifiedButton href={`/${lang}/blog`} variant="primary" size="lg" iconPosition="right">
                                <span set:html={translations.viewAll} />
                                <Fragment slot="icon-right">
                                    <svg
                                        class="w-full h-full"
                                        fill="none"
                                        viewBox="0 0 24 24"
                                        stroke="currentColor"
                                        stroke-width="2"
                                    >
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M17 8l4 4m0 0l-4 4m4-4H3" />
                                    </svg>
                                </Fragment>
                            </UnifiedButton>
                        </div>
                    )}
                </div>
            ) : (
                /* Empty State */
                <div class="text-center py-12">
                    <div class="w-16 h-16 mx-auto mb-4 text-foreground-muted" aria-hidden="true" set:html={DocumentEmptyIcon} />
                    <p class="text-foreground-secondary text-lg" set:html={translations.noArticles} />
                </div>
            )
        }
    </div>
</section>
