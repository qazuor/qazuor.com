---
/**
 * ParticlesDivider Component
 * @param {string} nextSectionColor - Color de la siguiente sección (formato hex: "#RRGGBB")
 * @param {string} upperSectionColor - Color de la sección superior (formato hex: "#RRGGBB")
 */

interface Props {
  nextSectionColor: string;
  upperSectionColor: string;
}

const { nextSectionColor, upperSectionColor } = Astro.props;

// Función para interpolar entre dos colores hexadecimales
function interpolateColor(color1: string, color2: string, factor: number): string {
  const hex1 = color1.replace('#', '');
  const hex2 = color2.replace('#', '');

  const r1 = Number.parseInt(hex1.substring(0, 2), 16);
  const g1 = Number.parseInt(hex1.substring(2, 4), 16);
  const b1 = Number.parseInt(hex1.substring(4, 6), 16);

  const r2 = Number.parseInt(hex2.substring(0, 2), 16);
  const g2 = Number.parseInt(hex2.substring(2, 4), 16);
  const b2 = Number.parseInt(hex2.substring(4, 6), 16);

  const r = Math.round(r1 + (r2 - r1) * factor);
  const g = Math.round(g1 + (g2 - g1) * factor);
  const b = Math.round(b1 + (b2 - b1) * factor);

  return `rgb(${r}, ${g}, ${b})`;
}

interface Particle {
  color: string;
  size: number;
  x: number;
  y: number;
  delay: number;
  duration: number;
}

// Generar partículas estáticas con colores interpolados
const particles: Particle[] = [];
for (let i = 0; i < 30; i++) {
  const colorFactor = Math.random();
  const size = Math.random() > 0.7 ? Math.random() * 6 + 4 : Math.random() * 3 + 1;
  const x = Math.random() * 100;
  const y = Math.random() * 100;
  const delay = Math.random() * 4;
  const duration = 3 + Math.random() * 4;

  particles.push({
    color: interpolateColor(upperSectionColor, nextSectionColor, colorFactor),
    size,
    x,
    y,
    delay,
    duration,
  });
}
---

<div class="particles-divider">
  <div class="particles-container">
    {
      particles.map((particle) => (
        <div
          class="particle"
          style={`
          background-color: ${particle.color};
          width: ${particle.size}px;
          height: ${particle.size}px;
          left: ${particle.x}%;
          top: ${particle.y}%;
          animation-delay: ${particle.delay}s;
          animation-duration: ${particle.duration}s;
        `}
        />
      ))
    }
  </div>

  <!-- Gradient overlay -->
  <div
    class="gradient-overlay"
    style={`background: linear-gradient(to bottom, ${upperSectionColor} 0%, ${nextSectionColor} 100%);`}
  >
  </div>
</div>

<style
  define:vars={{
    nextSectionColor,
    upperSectionColor,
  }}
>
  .particles-divider {
    @apply absolute left-0 right-0 -bottom-1 z-10 overflow-hidden leading-none pointer-events-none;
    height: 4rem;
  }

  @media (min-width: 768px) {
    .particles-divider {
      height: 5rem;
    }
  }

  .particles-container {
    @apply relative w-full h-full;
  }

  .gradient-overlay {
    @apply absolute inset-0;
    opacity: 0.3;
  }

  .particle {
    @apply absolute rounded-full;
    animation: particleFloat var(--duration, 4s) ease-in-out infinite;
    animation-delay: var(--delay, 0s);
  }

  @keyframes particleFloat {
    0%,
    100% {
      transform: translate(0, 0) scale(1);
      opacity: 0.6;
    }
    25% {
      transform: translate(10px, -5px) scale(1.1);
      opacity: 0.8;
    }
    50% {
      transform: translate(-8px, 8px) scale(0.9);
      opacity: 1;
    }
    75% {
      transform: translate(15px, -10px) scale(1.2);
      opacity: 0.7;
    }
  }

  /* Reduced motion fallback */
  @media (prefers-reduced-motion: reduce) {
    .particle {
      animation: none;
      opacity: 0.6;
    }
  }
</style>
