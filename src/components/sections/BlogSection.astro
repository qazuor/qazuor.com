---
import { getImage } from 'astro:assets';
import { getCollection } from 'astro:content';
import type { ImageMetadata } from 'astro';
import { BlogPostCard } from '@/components/cards/BlogPostCard';
import AnimatedGradientBackground from '@/components/ui/AnimatedGradientBackground.astro';
import SectionTitle from '@/components/ui/SectionTitle.astro';
import UnifiedButton from '@/components/ui/UnifiedButton.astro';
import fallbackProgramming from '@/content/blog/_images/code-typescript.jpg';
import fallbackFrontend from '@/content/blog/_images/react-frontend.jpg';
// Static imports for fallback images by category
import fallbackDefault from '@/content/blog/_images/web-development.jpg';
import fallbackWebdev from '@/content/blog/_images/web-development.jpg';
import { getRotatingColor } from '@/data/categoryColors';
import { processMarkdown } from '@/i18n/utils';
import DocumentEmptyIcon from '@/icons/ui/document-empty.svg?raw';

interface BlogPost {
    title: string;
    excerpt: string;
    date: string;
    readTime: string;
    tags: string[];
    slug: string;
}

interface Props {
    posts: BlogPost[];
    primaryColor?: string;
    translations: {
        title: string;
        subtitle: string;
        description?: string;
        viewAll: string;
        noArticles: string;
        readMore: string;
        readTime: string;
    };
    lang: string;
}

const { posts, primaryColor = '#8b5cf6', translations, lang } = Astro.props;

// Get full blog collection with images
const allBlogPosts = await getCollection('blog');

// Category fallback mapping (using static imports)
const categoryFallbacks: Record<string, ImageMetadata> = {
    Frontend: fallbackFrontend,
    Programming: fallbackProgramming,
    'Web Development': fallbackWebdev,
    WebAssembly: fallbackProgramming,
    JavaScript: fallbackFrontend,
    TypeScript: fallbackFrontend,
    React: fallbackFrontend,
    Astro: fallbackFrontend,
    'Node.js': fallbackProgramming,
    API: fallbackWebdev,
    Database: fallbackProgramming,
    DevOps: fallbackProgramming,
    Testing: fallbackProgramming,
    Performance: fallbackWebdev,
    Security: fallbackProgramming,
    Accessibility: fallbackWebdev,
    SEO: fallbackWebdev,
    Design: fallbackFrontend,
    'UI/UX': fallbackFrontend,
    CSS: fallbackFrontend,
    Tutorial: fallbackWebdev,
    Guide: fallbackWebdev,
    Article: fallbackDefault
};

// Blog card image dimensions (16:9 aspect ratio for cards)
const BLOG_IMAGE_WIDTH = 600;
const BLOG_IMAGE_HEIGHT = 400;

// Map posts with images (optimized by Astro)
const postsWithImages = await Promise.all(
    posts.slice(0, 3).map(async (post) => {
        const fullPost = allBlogPosts.find((p: { slug: string }) => `/${lang}/blog/${p.slug}` === post.slug);
        const category = fullPost?.data.category || post.tags[0] || 'Article';

        let optimizedImage = { src: '', width: BLOG_IMAGE_WIDTH, height: BLOG_IMAGE_HEIGHT };

        // Try to use post image first
        if (fullPost?.data.image) {
            try {
                const img = await getImage({
                    src: fullPost.data.image as ImageMetadata,
                    width: BLOG_IMAGE_WIDTH,
                    height: BLOG_IMAGE_HEIGHT,
                    format: 'webp'
                });
                optimizedImage = { src: img.src, width: BLOG_IMAGE_WIDTH, height: BLOG_IMAGE_HEIGHT };
            } catch (error) {
                console.warn(`Failed to optimize image for ${post.slug}:`, error);
            }
        }

        // Fallback to category placeholder
        if (!optimizedImage.src) {
            const fallbackImageSrc = categoryFallbacks[category] || fallbackDefault;
            try {
                const img = await getImage({
                    src: fallbackImageSrc,
                    width: BLOG_IMAGE_WIDTH,
                    height: BLOG_IMAGE_HEIGHT,
                    format: 'webp'
                });
                optimizedImage = { src: img.src, width: BLOG_IMAGE_WIDTH, height: BLOG_IMAGE_HEIGHT };
            } catch (error) {
                console.warn(`Failed to load placeholder for category ${category}:`, error);
                // Last resort fallback - use default placeholder without optimization
                optimizedImage = { src: '/placeholder.jpg', width: BLOG_IMAGE_WIDTH, height: BLOG_IMAGE_HEIGHT };
            }
        }

        return {
            ...post,
            image: optimizedImage,
            category
        };
    })
);
---

<section
    class="relative section section-purple-blue overflow-hidden"
    id="blog"
    style={`background-color: ${primaryColor}`}
>
    <!-- Animated Gradient Background -->
    <AnimatedGradientBackground />

    <div class="container-custom">
        <!-- Section Title -->
        <SectionTitle
            title={translations.title}
            subtitle={translations.subtitle}
            description={translations.description}
            descriptionClassName="!text-base !max-w-3xl mx-auto mt-6 leading-relaxed"
        />

        <!-- Blog Cards Container -->
        <div class="blog-cards-container flex flex-col md:flex-row justify-between items-stretch gap-4 mb-12 min-h-[500px] md:min-h-[600px]" data-post-count={postsWithImages.length}>
            {
                postsWithImages.map((post, index) => (
                    <BlogPostCard
                        client:load
                        title={post.title}
                        excerpt={processMarkdown(post.excerpt)}
                        category={post.category}
                        image={post.image}
                        slug={post.slug}
                        categoryColor={getRotatingColor(index).bg}
                    />
                ))
            }
        </div>

        {/* View All Button */}
        {
            posts.length > 3 && (
                <div class="text-center">
                    <UnifiedButton
                        href={`/${lang}/blog`}
                        variant="primary"
                        size="lg"
                        iconPosition="right"
                    >
                        <span set:html={translations.viewAll} />
                        <Fragment slot="icon-right">
                            <svg class="w-full h-full" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M17 8l4 4m0 0l-4 4m4-4H3" />
                            </svg>
                        </Fragment>
                    </UnifiedButton>
                </div>
            )
        }

        {/* Empty State */}
        {
            posts.length === 0 && (
                <div class="text-center py-12">
                    <div class="w-16 h-16 mx-auto mb-4 text-foreground-muted" aria-hidden="true" set:html={DocumentEmptyIcon} />
                    <p class="text-foreground-secondary text-lg" set:html={translations.noArticles} />
                </div>
            )
        }
    </div>
</section>
