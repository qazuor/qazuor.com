---
export interface Props {
    gap?: number;
    speed?: number;
    colors?: string[];
    colorsLight?: string[];
    noFocus?: boolean;
    class?: string;
}

const {
    gap = 5,
    speed = 35,
    colors = ['#f8fafc', '#f1f5f9', '#cbd5e1'],
    colorsLight = ['#1e293b', '#334155', '#475569'],
    noFocus = false,
    class: className = ''
} = Astro.props;

const colorsString = colors.join(',');
const colorsLightString = colorsLight.join(',');
---

<pixel-canvas
    data-gap={gap}
    data-speed={speed}
    data-colors={colorsString}
    data-colors-light={colorsLightString}
    data-no-focus={noFocus ? '' : undefined}
    class={className}
>
</pixel-canvas>

<script>
    class Pixel {
        private width: number;
        private height: number;
        private ctx: CanvasRenderingContext2D;
        private x: number;
        private y: number;
        private color: string;
        private speed: number;
        private size: number;
        private sizeStep: number;
        private minSize: number;
        private maxSizeInteger: number;
        private maxSize: number;
        private delay: number;
        private counter: number;
        private counterStep: number;
        isIdle: boolean;
        private isReverse: boolean;
        private isShimmer: boolean;

        constructor(
            canvas: HTMLCanvasElement,
            context: CanvasRenderingContext2D,
            x: number,
            y: number,
            color: string,
            speed: number,
            delay: number
        ) {
            this.width = canvas.width;
            this.height = canvas.height;
            this.ctx = context;
            this.x = x;
            this.y = y;
            this.color = color;
            this.speed = this.getRandomValue(0.1, 0.9) * speed;
            this.size = 0;
            this.sizeStep = Math.random() * 0.6;
            this.minSize = 1;
            this.maxSizeInteger = 4;
            this.maxSize = this.getRandomValue(this.minSize, this.maxSizeInteger);
            this.delay = delay;
            this.counter = 0;
            this.counterStep = Math.random() * 4 + (this.width + this.height) * 0.01;
            this.isIdle = false;
            this.isReverse = false;
            this.isShimmer = false;
        }

        private getRandomValue(min: number, max: number): number {
            return Math.random() * (max - min) + min;
        }

        private draw(): void {
            const centerOffset = this.maxSizeInteger * 0.5 - this.size * 0.5;

            this.ctx.fillStyle = this.color;
            this.ctx.fillRect(this.x + centerOffset, this.y + centerOffset, this.size, this.size);
        }

        appear(): void {
            this.isIdle = false;

            if (this.counter <= this.delay) {
                this.counter += this.counterStep;
                return;
            }

            if (this.size >= this.maxSize) {
                this.isShimmer = true;
            }

            if (this.isShimmer) {
                this.shimmer();
            } else {
                this.size += this.sizeStep;
            }

            this.draw();
        }

        disappear(): void {
            this.isShimmer = false;
            this.counter = 0;

            if (this.size <= 0) {
                this.isIdle = true;
                return;
            } else {
                this.size -= 0.1;
            }

            this.draw();
        }

        private shimmer(): void {
            if (this.size >= this.maxSize) {
                this.isReverse = true;
            } else if (this.size <= this.minSize) {
                this.isReverse = false;
            }

            if (this.isReverse) {
                this.size -= this.speed;
            } else {
                this.size += this.speed;
            }
        }
    }

    class PixelCanvas extends HTMLElement {
        static css = `
            :host {
                display: grid;
                inline-size: 100%;
                block-size: 100%;
                overflow: hidden;
            }
        `;

        private _parent: ParentNode | null = null;
        // Made public to allow checking initialization state for View Transitions
        public canvas: HTMLCanvasElement | null = null;
        public ctx: CanvasRenderingContext2D | null = null;
        private pixels: Pixel[] = [];
        private animationFrame: number = 0;
        private timeInterval: number = 1000 / 60;
        private timePrevious: number = 0;
        private reducedMotion: boolean = false;
        private resizeObserver: ResizeObserver | null = null;
        private themeObserver: MutationObserver | null = null;

        get colorsDark(): string[] {
            return this.dataset.colors?.split(',').map((c) => c.trim()) || ['#f8fafc', '#f1f5f9', '#cbd5e1'];
        }

        get colorsLight(): string[] {
            return this.dataset.colorsLight?.split(',').map((c) => c.trim()) || ['#1e293b', '#334155', '#475569'];
        }

        get colors(): string[] {
            const isDark = document.documentElement.classList.contains('dark');
            return isDark ? this.colorsDark : this.colorsLight;
        }

        get gap(): number {
            const value = Number.parseInt(this.dataset.gap || '5');
            const min = 4;
            const max = 50;

            if (value <= min) {
                return min;
            } else if (value >= max) {
                return max;
            } else {
                return value;
            }
        }

        get speed(): number {
            const value = Number.parseInt(this.dataset.speed || '35');
            const min = 0;
            const max = 100;
            const throttle = 0.001;

            if (value <= min || this.reducedMotion) {
                return min;
            } else if (value >= max) {
                return max * throttle;
            } else {
                return value * throttle;
            }
        }

        get noFocus(): boolean {
            return this.hasAttribute('data-no-focus');
        }

        connectedCallback(): void {
            const canvas = document.createElement('canvas');
            const sheet = new CSSStyleSheet();

            this._parent = this.parentNode;
            const shadowroot = this.attachShadow({ mode: 'open' });

            sheet.replaceSync(PixelCanvas.css);

            shadowroot.adoptedStyleSheets = [sheet];
            shadowroot.append(canvas);
            this.canvas = shadowroot.querySelector('canvas');
            this.ctx = this.canvas?.getContext('2d') || null;
            this.timeInterval = 1000 / 60;
            this.timePrevious = performance.now();
            this.reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

            this.init();
            this.resizeObserver = new ResizeObserver(() => this.init());
            this.resizeObserver.observe(this as unknown as Element);

            this._parent?.addEventListener('mouseenter', this);
            this._parent?.addEventListener('mouseleave', this);

            if (!this.noFocus) {
                this._parent?.addEventListener('focusin', this);
                this._parent?.addEventListener('focusout', this);
            }

            // Observe theme changes
            this.themeObserver = new MutationObserver((mutations) => {
                for (const mutation of mutations) {
                    if (mutation.attributeName === 'class') {
                        this.init(); // Reinitialize with new colors
                    }
                }
            });
            this.themeObserver.observe(document.documentElement, { attributes: true });
        }

        disconnectedCallback(): void {
            this.resizeObserver?.disconnect();
            this.themeObserver?.disconnect();
            this._parent?.removeEventListener('mouseenter', this);
            this._parent?.removeEventListener('mouseleave', this);

            if (!this.noFocus) {
                this._parent?.removeEventListener('focusin', this);
                this._parent?.removeEventListener('focusout', this);
            }

            this._parent = null;
        }

        handleEvent(event: Event): void {
            switch (event.type) {
                case 'mouseenter':
                    this.handleMouseEnter();
                    break;
                case 'mouseleave':
                    this.handleMouseLeave();
                    break;
                case 'focusin':
                    this.handleFocusIn(event as FocusEvent);
                    break;
                case 'focusout':
                    this.handleFocusOut(event as FocusEvent);
                    break;
            }
        }

        private handleMouseEnter(): void {
            this.runAnimation('appear');
        }

        private handleMouseLeave(): void {
            this.runAnimation('disappear');
        }

        private handleFocusIn(e: FocusEvent): void {
            const target = e.currentTarget as HTMLElement;
            if (target?.contains(e.relatedTarget as Node)) return;
            this.runAnimation('appear');
        }

        private handleFocusOut(e: FocusEvent): void {
            const target = e.currentTarget as HTMLElement;
            if (target?.contains(e.relatedTarget as Node)) return;
            this.runAnimation('disappear');
        }

        private runAnimation(name: 'appear' | 'disappear'): void {
            cancelAnimationFrame(this.animationFrame);
            this.animationFrame = this.animatePixels(name);
        }

        // Made public to allow re-initialization after View Transitions
        public init(): void {
            if (!this.canvas || !this.ctx) return;

            const rect = this.getBoundingClientRect();
            const width = Math.floor(rect.width);
            const height = Math.floor(rect.height);

            this.pixels = [];
            this.canvas.width = width;
            this.canvas.height = height;
            this.canvas.style.width = `${width}px`;
            this.canvas.style.height = `${height}px`;
            this.createPixels();
        }

        private getDistanceToCanvasCenter(x: number, y: number): number {
            if (!this.canvas) return 0;
            const dx = x - this.canvas.width / 2;
            const dy = y - this.canvas.height / 2;
            const distance = Math.sqrt(dx * dx + dy * dy);

            return distance;
        }

        private createPixels(): void {
            if (!this.canvas || !this.ctx) return;

            // Calculate max distance (corner to center)
            const maxDistance = Math.sqrt(
                Math.pow(this.canvas.width / 2, 2) + Math.pow(this.canvas.height / 2, 2)
            );

            for (let x = 0; x < this.canvas.width; x += this.gap) {
                for (let y = 0; y < this.canvas.height; y += this.gap) {
                    const distance = this.getDistanceToCanvasCenter(x, y);
                    const normalizedDistance = distance / maxDistance; // 0 = center, 1 = corner

                    // Skip pixels in center with probability based on distance
                    // Center (0) = 100% skip chance, Edge (1) = 0% skip chance
                    const skipChance = Math.pow(1 - normalizedDistance, 6) * 1.0;
                    if (Math.random() < skipChance) continue;

                    const color = this.colors[Math.floor(Math.random() * this.colors.length)];
                    const delay = this.reducedMotion ? 0 : distance;

                    this.pixels.push(new Pixel(this.canvas, this.ctx, x, y, color, this.speed, delay));
                }
            }
        }

        private animatePixels(fnName: 'appear' | 'disappear'): number {
            this.animationFrame = requestAnimationFrame(() => this.animatePixels(fnName));

            const timeNow = performance.now();
            const timePassed = timeNow - this.timePrevious;

            if (timePassed < this.timeInterval) return this.animationFrame;

            this.timePrevious = timeNow - (timePassed % this.timeInterval);

            if (!this.canvas || !this.ctx) return this.animationFrame;

            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

            for (const pixel of this.pixels) {
                pixel[fnName]();
            }

            if (this.pixels.every((pixel) => pixel.isIdle)) {
                cancelAnimationFrame(this.animationFrame);
            }

            return this.animationFrame;
        }
    }

    // Register the custom element if not already registered
    if (!customElements.get('pixel-canvas')) {
        customElements.define('pixel-canvas', PixelCanvas as unknown as CustomElementConstructor);

        // Re-initialize pixel-canvas elements after View Transitions
        // This is needed because View Transitions may not properly trigger connectedCallback
        // Only register once when the custom element is first defined
        document.addEventListener('astro:page-load', () => {
            // Small delay to ensure DOM is fully ready
            requestAnimationFrame(() => {
                const pixelCanvases = document.querySelectorAll('pixel-canvas');
                pixelCanvases.forEach((el) => {
                    const canvas = el as InstanceType<typeof PixelCanvas>;
                    // Force re-initialization by calling init if the canvas exists
                    if (canvas.canvas && canvas.ctx) {
                        canvas.init();
                    }
                });
            });
        });
    }
</script>
